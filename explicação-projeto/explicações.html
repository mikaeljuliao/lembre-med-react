<!--
.

📝 Aula: Salvando e carregando dados com localStorage no React (versão final)

1️⃣ O que é localStorage?
. É um recurso do navegador que guarda dados no próprio computador do usuário.
. Diferente de um banco de dados, só guarda strings (texto).
. Os dados continuam lá mesmo se o usuário fechar ou recarregar a página.

Exemplo simples no console:
localStorage.setItem('nome', 'Mikael'); // salvar
localStorage.getItem('nome');           // "Mikael"


2️⃣ Por que usamos JSON.stringify e JSON.parse?
. O localStorage só aceita texto.
. Nosso estado remedios é um array de objetos.
. Precisamos converter para string para salvar, e converter de volta para objeto para usar.

JSON.stringify(remedios) // transforma array/objeto em string JSON
JSON.parse(string)       // transforma string JSON de volta em array/objeto



3️⃣ A lógica no React:
const [remedios, setRemedios] = useState(() => {
  const dadosSalvos = localStorage.getItem('remedios');
  return dadosSalvos ? JSON.parse(dadosSalvos) : [];
});

useEffect(() => {
  localStorage.setItem("remedios", JSON.stringify(remedios));
}, [remedios]);



4️⃣ Por que usamos useState(() => {...}) com função inicial?
. O React só executa essa função na primeira renderização.
. Com isso, ele lê do localStorage uma única vez e já inicializa remedios com o que estava salvo.
. Sem essa função, você precisaria de dois useEffect: um para carregar e outro para salvar.
. Assim, tudo fica mais limpo.



5️⃣ O operador ternário (condição ? valor1 : valor2):

Dentro do useState usamos:
return dadosSalvos ? JSON.parse(dadosSalvos) : [];


Isso significa:
. Se dadosSalvos existe → converte e retorna os dados.
. Se não existe → retorna um array vazio.


É um jeito curto de escrever:
if (dadosSalvos) {
  return JSON.parse(dadosSalvos);
} else {
  return [];
}



6️⃣ O que significa o [remedios] no useEffect?
. É a lista de dependências.
. O React só roda o useEffect de novo quando algo dessa lista muda.
. Colocando [remedios] → ele roda sempre que remedios mudar.
. Se deixasse [], rodaria só uma vez no início.



7️⃣ Detalhes do localStorage:
. O localStorage.setItem recebe 2 parâmetros:
. Chave: nome do item (string) → 'remedios'.
. Valor: o que quer salvar (também string).

Então:
localStorage.setItem('remedios', JSON.stringify(remedios))

. "remedios" é a chave.
. JSON.stringify(remedios) é o valor salvo (string).


Para ler:
localStorage.getItem('remedios')

. Retorna a string. Se quiser o array de volta, faz:
. JSON.parse(localStorage.getItem('remedios'))



8️⃣ Resumo do fluxo
. Página abre → useState lê localStorage e preenche remedios.
. Usuário adiciona um remédio → setRemedios atualiza o estado.
. useEffect detecta mudança em remedios → salva os novos dados no localStorage.
. Se recarregar a página → useState pega os dados salvos e carrega de volta.


9️⃣ Vantagens dessa abordagem
. Não precisa banco de dados para coisas simples.
. Os dados ficam sempre atualizados sem funções extras.
. Estado inicial já vem com os dados salvos (sem “flash” vazio).
. Evita ter dois useEffect brigando entre si.


💡 Resumo em uma frase:
“O localStorage é um armário do navegador.
Usamos useState para pegar o que está dentro quando o app carrega,
e useEffect para guardar tudo de novo sempre que algo mudar.”
















📚 Aula: Listagem de Medicamentos no React

1. O objetivo da feature:

O que queríamos com essa branch era:
. ✅ Ler um arquivo JSON (medicamentos.json) com dados de medicamentos (nome, dose, frequência, horário etc.).
. ✅ Exibir esses dados automaticamente na tela, sem que o usuário precise cadastrar.
. ✅ Deixar esses dados separados da lógica principal, ou seja, mantê-los no JSON em vez de hardcodar dentro do componente.



2. Preparando os estados:
No React usamos estados (useState) para guardar informações que mudam durante a execução da aplicação.

No começo do componente criamos dois estados:

const [remedios, setRemedios] = useState([]); 
const [medicamentos, setMedicamentos] = useState([]);

. remedios → armazena os medicamentos que o usuário adiciona manualmente no formulário.
. medicamentos → armazena os medicamentos que vêm do arquivo JSON.

Assim conseguimos trabalhar separadamente com cada fonte de dados.



3. Buscando o JSON com useEffect

Para carregar os dados assim que a página abre, usamos o hook useEffect.

useEffect(() => {
  fetch("/medicamentos.json")
    .then((res) => res.json())
    .then((data) => setMedicamentos(data))
    .catch((error) =>
      console.log("Erro ao carregar medicamentos", error)
    );
}, []);

Explicação:
. fetch("/medicamentos.json") → faz a requisição para o arquivo JSON.
. .then(res => res.json()) → transforma a resposta em um objeto JavaScript.
. .then(data => setMedicamentos(data)) → guarda esses dados no estado medicamentos.
. catch(...) → captura possíveis erros.
. O [] no final garante que isso só rode uma vez, quando o componente for montado.



4. Renderizando os medicamentos:

Depois que o JSON foi carregado no estado medicamentos, basta percorrer esse array com .map() e renderizar na tela.

<div className="mt-10">
  <ul>
    {medicamentos.map((medicamento) => (
      <li key={medicamento.id}>
        <strong>
          {medicamento.nome} - {medicamento.dose}
        </strong>{" "}
        <br />
        horário: {medicamento.horario} - frequência:{" "}
        {medicamento.frequencia}
      </li>
    ))}
  </ul>
</div>


O que acontece aqui:
. medicamentos.map(...) → percorre cada item do array.
. key={medicamento.id} → cada item precisa de uma chave única.
. Dentro do JSX mostramos nome, dose, horário e frequência.
. Ou seja, sempre que o arquivo JSON mudar, a interface automaticamente vai refletir esses dados.



5. Integração com a lógica já existente:
Antes, nosso app só cadastrava manualmente com o formulário (remedios).
Agora temos duas listas:

. Lista de remédios cadastrados pelo usuário
. Lista de medicamentos vindos do JSON

Assim a aplicação mostra tanto o que o usuário digitou quanto o que já estava registrado no “banco” de medicamentos.



6. Por que isso é importante?
. 📂 Separação de responsabilidades → os dados ficam em um arquivo externo (JSON).
. ⚡ Reutilização → podemos mudar o JSON sem alterar o código.
. 🔄 Dinamicidade → se o JSON for atualizado, a interface também é.
. 💻 Próxima evolução → no futuro, esse fetch pode vir de uma API real, sem mudar muita coisa no código.


🚀 Conclusão

Na branch listagem-medicamento, aprendemos:
1. Como usar useState para armazenar dados vindos de diferentes fontes.
2. Como usar useEffect + fetch para buscar dados de um JSON.
3. Como percorrer arrays com .map() para renderizar listas no React.
4. Como separar a lógica de medicamentos cadastrados manualmente e carregados automaticamente.

Isso fecha a funcionalidade de listar medicamentos.

Na prática, você agora tem:
. Um mini banco de dados local (JSON).
. Integração desse “banco” com React.
. Exibição dinâmica dos dados.
-->