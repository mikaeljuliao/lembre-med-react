<!--
.

ğŸ“ Aula: Salvando e carregando dados com localStorage no React (versÃ£o final)

1ï¸âƒ£ O que Ã© localStorage?
. Ã‰ um recurso do navegador que guarda dados no prÃ³prio computador do usuÃ¡rio.
. Diferente de um banco de dados, sÃ³ guarda strings (texto).
. Os dados continuam lÃ¡ mesmo se o usuÃ¡rio fechar ou recarregar a pÃ¡gina.

Exemplo simples no console:
localStorage.setItem('nome', 'Mikael'); // salvar
localStorage.getItem('nome');           // "Mikael"


2ï¸âƒ£ Por que usamos JSON.stringify e JSON.parse?
. O localStorage sÃ³ aceita texto.
. Nosso estado remedios Ã© um array de objetos.
. Precisamos converter para string para salvar, e converter de volta para objeto para usar.

JSON.stringify(remedios) // transforma array/objeto em string JSON
JSON.parse(string)       // transforma string JSON de volta em array/objeto



3ï¸âƒ£ A lÃ³gica no React:
const [remedios, setRemedios] = useState(() => {
  const dadosSalvos = localStorage.getItem('remedios');
  return dadosSalvos ? JSON.parse(dadosSalvos) : [];
});

useEffect(() => {
  localStorage.setItem("remedios", JSON.stringify(remedios));
}, [remedios]);



4ï¸âƒ£ Por que usamos useState(() => {...}) com funÃ§Ã£o inicial?
. O React sÃ³ executa essa funÃ§Ã£o na primeira renderizaÃ§Ã£o.
. Com isso, ele lÃª do localStorage uma Ãºnica vez e jÃ¡ inicializa remedios com o que estava salvo.
. Sem essa funÃ§Ã£o, vocÃª precisaria de dois useEffect: um para carregar e outro para salvar.
. Assim, tudo fica mais limpo.



5ï¸âƒ£ O operador ternÃ¡rio (condiÃ§Ã£o ? valor1 : valor2):

Dentro do useState usamos:
return dadosSalvos ? JSON.parse(dadosSalvos) : [];


Isso significa:
. Se dadosSalvos existe â†’ converte e retorna os dados.
. Se nÃ£o existe â†’ retorna um array vazio.


Ã‰ um jeito curto de escrever:
if (dadosSalvos) {
  return JSON.parse(dadosSalvos);
} else {
  return [];
}



6ï¸âƒ£ O que significa o [remedios] no useEffect?
. Ã‰ a lista de dependÃªncias.
. O React sÃ³ roda o useEffect de novo quando algo dessa lista muda.
. Colocando [remedios] â†’ ele roda sempre que remedios mudar.
. Se deixasse [], rodaria sÃ³ uma vez no inÃ­cio.



7ï¸âƒ£ Detalhes do localStorage:
. O localStorage.setItem recebe 2 parÃ¢metros:
. Chave: nome do item (string) â†’ 'remedios'.
. Valor: o que quer salvar (tambÃ©m string).

EntÃ£o:
localStorage.setItem('remedios', JSON.stringify(remedios))

. "remedios" Ã© a chave.
. JSON.stringify(remedios) Ã© o valor salvo (string).


Para ler:
localStorage.getItem('remedios')

. Retorna a string. Se quiser o array de volta, faz:
. JSON.parse(localStorage.getItem('remedios'))



8ï¸âƒ£ Resumo do fluxo
. PÃ¡gina abre â†’ useState lÃª localStorage e preenche remedios.
. UsuÃ¡rio adiciona um remÃ©dio â†’ setRemedios atualiza o estado.
. useEffect detecta mudanÃ§a em remedios â†’ salva os novos dados no localStorage.
. Se recarregar a pÃ¡gina â†’ useState pega os dados salvos e carrega de volta.


9ï¸âƒ£ Vantagens dessa abordagem
. NÃ£o precisa banco de dados para coisas simples.
. Os dados ficam sempre atualizados sem funÃ§Ãµes extras.
. Estado inicial jÃ¡ vem com os dados salvos (sem â€œflashâ€ vazio).
. Evita ter dois useEffect brigando entre si.


ğŸ’¡ Resumo em uma frase:
â€œO localStorage Ã© um armÃ¡rio do navegador.
Usamos useState para pegar o que estÃ¡ dentro quando o app carrega,
e useEffect para guardar tudo de novo sempre que algo mudar.â€
















ğŸ“š Aula: Listagem de Medicamentos no React

1. O objetivo da feature:

O que querÃ­amos com essa branch era:
. âœ… Ler um arquivo JSON (medicamentos.json) com dados de medicamentos (nome, dose, frequÃªncia, horÃ¡rio etc.).
. âœ… Exibir esses dados automaticamente na tela, sem que o usuÃ¡rio precise cadastrar.
. âœ… Deixar esses dados separados da lÃ³gica principal, ou seja, mantÃª-los no JSON em vez de hardcodar dentro do componente.



2. Preparando os estados:
No React usamos estados (useState) para guardar informaÃ§Ãµes que mudam durante a execuÃ§Ã£o da aplicaÃ§Ã£o.

No comeÃ§o do componente criamos dois estados:

const [remedios, setRemedios] = useState([]); 
const [medicamentos, setMedicamentos] = useState([]);

. remedios â†’ armazena os medicamentos que o usuÃ¡rio adiciona manualmente no formulÃ¡rio.
. medicamentos â†’ armazena os medicamentos que vÃªm do arquivo JSON.

Assim conseguimos trabalhar separadamente com cada fonte de dados.



3. Buscando o JSON com useEffect

Para carregar os dados assim que a pÃ¡gina abre, usamos o hook useEffect.

useEffect(() => {
  fetch("/medicamentos.json")
    .then((res) => res.json())
    .then((data) => setMedicamentos(data))
    .catch((error) =>
      console.log("Erro ao carregar medicamentos", error)
    );
}, []);

ExplicaÃ§Ã£o:
. fetch("/medicamentos.json") â†’ faz a requisiÃ§Ã£o para o arquivo JSON.
. .then(res => res.json()) â†’ transforma a resposta em um objeto JavaScript.
. .then(data => setMedicamentos(data)) â†’ guarda esses dados no estado medicamentos.
. catch(...) â†’ captura possÃ­veis erros.
. O [] no final garante que isso sÃ³ rode uma vez, quando o componente for montado.



4. Renderizando os medicamentos:

Depois que o JSON foi carregado no estado medicamentos, basta percorrer esse array com .map() e renderizar na tela.

<div className="mt-10">
  <ul>
    {medicamentos.map((medicamento) => (
      <li key={medicamento.id}>
        <strong>
          {medicamento.nome} - {medicamento.dose}
        </strong>{" "}
        <br />
        horÃ¡rio: {medicamento.horario} - frequÃªncia:{" "}
        {medicamento.frequencia}
      </li>
    ))}
  </ul>
</div>


O que acontece aqui:
. medicamentos.map(...) â†’ percorre cada item do array.
. key={medicamento.id} â†’ cada item precisa de uma chave Ãºnica.
. Dentro do JSX mostramos nome, dose, horÃ¡rio e frequÃªncia.
. Ou seja, sempre que o arquivo JSON mudar, a interface automaticamente vai refletir esses dados.



5. IntegraÃ§Ã£o com a lÃ³gica jÃ¡ existente:
Antes, nosso app sÃ³ cadastrava manualmente com o formulÃ¡rio (remedios).
Agora temos duas listas:

. Lista de remÃ©dios cadastrados pelo usuÃ¡rio
. Lista de medicamentos vindos do JSON

Assim a aplicaÃ§Ã£o mostra tanto o que o usuÃ¡rio digitou quanto o que jÃ¡ estava registrado no â€œbancoâ€ de medicamentos.



6. Por que isso Ã© importante?
. ğŸ“‚ SeparaÃ§Ã£o de responsabilidades â†’ os dados ficam em um arquivo externo (JSON).
. âš¡ ReutilizaÃ§Ã£o â†’ podemos mudar o JSON sem alterar o cÃ³digo.
. ğŸ”„ Dinamicidade â†’ se o JSON for atualizado, a interface tambÃ©m Ã©.
. ğŸ’» PrÃ³xima evoluÃ§Ã£o â†’ no futuro, esse fetch pode vir de uma API real, sem mudar muita coisa no cÃ³digo.


ğŸš€ ConclusÃ£o

Na branch listagem-medicamento, aprendemos:
1. Como usar useState para armazenar dados vindos de diferentes fontes.
2. Como usar useEffect + fetch para buscar dados de um JSON.
3. Como percorrer arrays com .map() para renderizar listas no React.
4. Como separar a lÃ³gica de medicamentos cadastrados manualmente e carregados automaticamente.

Isso fecha a funcionalidade de listar medicamentos.

Na prÃ¡tica, vocÃª agora tem:
. Um mini banco de dados local (JSON).
. IntegraÃ§Ã£o desse â€œbancoâ€ com React.
. ExibiÃ§Ã£o dinÃ¢mica dos dados.
























ğŸ”¹ 1. git checkout develop

Esse comando faz vocÃª entrar na branch develop.

Se jÃ¡ estiver nela, o Git responde algo como Already on 'develop'.

ğŸ”¹ 2. git merge main

Aqui Ã© onde sempre rola confusÃ£o ğŸ‘€

Esse comando pega o histÃ³rico da main e junta dentro da develop.

Ou seja: vocÃª estÃ¡ atualizando a develop com tudo que jÃ¡ existe na main.

NÃ£o Ã© o contrÃ¡rio. A main nÃ£o recebe nada aqui.

ğŸ“Œ EntÃ£o:

Branch ativa (onde vocÃª estÃ¡) = quem vai ser atualizada.

Branch do merge (que vocÃª passa como argumento) = quem traz as mudanÃ§as.

ğŸ‘‰ Como vocÃª estava em develop, o merge significa:

"junte as mudanÃ§as da main dentro da develop".

ğŸ”¹ 3. O que Ã© merge

Exatamente: merge = juntar o histÃ³rico de duas branches.
Ele cria um commit especial (merge commit) se houver diferenÃ§as entre elas.
Se nÃ£o houver conflitos, o Git une automaticamente.

ğŸ“Œ Se houver conflitos, vocÃª precisa resolver manualmente (como aconteceu antes).

ğŸ”¹ 4. git push origin develop

O push envia a sua branch local (develop) pro repositÃ³rio remoto (GitHub, GitLab etc.).

origin = apelido padrÃ£o pro repositÃ³rio remoto.

develop = branch que vocÃª estÃ¡ enviando.

ğŸ’¡ Se vocÃª sÃ³ fizesse o merge localmente e nÃ£o desse o push, a develop remota ficaria desatualizada.
O push origin develop garante que a branch remota fique igual Ã  sua local.




âœ… Resumindo sua explicaÃ§Ã£o corrigida:
. checkout develop â†’ entro na branch develop.
. merge main â†’ atualizo develop com tudo que estÃ¡ na main.
. push origin develop â†’ envio a develop atualizada pro GitHub.


















ğŸ§  Aula: Criando a funcionalidade Remover RemÃ©dio
ğŸ¯ Objetivo:

Permitir que o usuÃ¡rio remova um remÃ©dio da lista exibida na tela, de forma dinÃ¢mica, sem precisar recarregar a pÃ¡gina.

ğŸ§© Etapas de implementaÃ§Ã£o
1ï¸âƒ£ Entendimento do problema

QuerÃ­amos que cada remÃ©dio adicionado tivesse um botÃ£o de remover.
Quando o usuÃ¡rio clicasse, aquele remÃ©dio deveria sumir da lista imediatamente.

Pra isso, precisarÃ­amos:
. Acessar o estado atual da lista de remÃ©dios (remedios);
. Remover apenas o item selecionado, sem alterar o resto;
. Atualizar o estado pra refletir essa mudanÃ§a na interface 
(React faz isso automaticamente quando o estado muda).



2ï¸âƒ£ Criando a funÃ§Ã£o de remover

Usamos o React Hook useState que controla a lista de remÃ©dios:

const [remedios, setRemedios] = useState([]);


Depois criamos a funÃ§Ã£o removerRemedio:

function removerRemedio(idDoRemedio) {
  setRemedios((listaAnteriorDeRemedios) => 
    listaAnteriorDeRemedios.filter((remedio) => remedio.id !== idDoRemedio)
  );
}

ğŸ§© Explicando linha por linha:
. setRemedios(...) â†’ Ã© a funÃ§Ã£o que atualiza o estado remedios.
. (listaAnteriorDeRemedios) â†’ Ã© o estado antigo (a lista antes da remoÃ§Ã£o).
Esse nome Ã© sÃ³ pra clareza. Em alguns cÃ³digos aparece como prev, que Ã© 
abreviaÃ§Ã£o de previous, ou seja, â€œanteriorâ€.
. .filter() â†’ cria uma nova lista, sem modificar a original, mantendo apenas 
os elementos que passam no teste.
. (remedio) => remedio.id !== idDoRemedio â†’ esse Ã© o teste: sÃ³ ficam na lista os 
remÃ©dios cujo id nÃ£o Ã© igual ao id que queremos remover.
. O React entÃ£o re-renderiza o componente mostrando a nova lista, jÃ¡ sem o remÃ©dio removido.



3ï¸âƒ£ Ligando o botÃ£o Ã  funÃ§Ã£o:

Dentro do map() que mostra os remÃ©dios na tela, adicionamos um botÃ£o:

<button
  onClick={() => removerRemedio(remedio.id)}
  className="mt-2 bg-red-500 text-white px-3 py-1 rounded hover:bg-red-600"
>
  Remover
</button>

ğŸ§© O que acontece aqui:
. O onClick chama a funÃ§Ã£o removerRemedio, passando o id do remÃ©dio.
. Assim que o botÃ£o Ã© clicado, a funÃ§Ã£o roda e o item some da tela.



4ï¸âƒ£ Testando a funcionalidade:

Passos testados:
1. Adicionar 2 ou mais remÃ©dios.
2. Clicar em â€œRemoverâ€ em um deles.
3. Verificar se apenas aquele sumiu da lista.
4. Conferir se o resto da lista continua igual. âœ…

ğŸ§¹ Resultado final (resumo visual)
function removerRemedio(idDoRemedio) {
  setRemedios((listaAnterior) =>
    listaAnterior.filter((remedio) => remedio.id !== idDoRemedio)
  );
}



ğŸ’¡ Resumo conceitual:
.filter() percorre a lista e cria uma nova, com todos os itens que 
nÃ£o tÃªm o ID igual ao que queremos remover.
Depois setRemedios atualiza o estado com essa nova lista.
O React automaticamente refaz a renderizaÃ§Ã£o â€” e o item desaparece da tela.


ğŸ“š ConclusÃ£o
. Usamos o conceito de imutabilidade do React: nunca alteramos o 
estado direto, sempre criamos uma nova lista.
. Entendemos o uso do callback no setState, pra trabalhar com o 
valor anterior de forma segura.
. Aplicamos o .filter(), uma funÃ§Ã£o nativa do JavaScript muito 
usada pra manipular arrays no React.



























ğŸ§  Aula Completa â€“ Funcionalidade â€œEditar RemÃ©dioâ€ no React

ğŸ“˜ Objetivo:
Permitir que o usuÃ¡rio adicione, edite e atualize remÃ©dios sem criar duplicaÃ§Ãµes, 
mantendo o estado da lista atualizado em tempo real.
Essa funcionalidade representa o â€œUâ€ do CRUD (Update) â€” atualizar dados existentes.

ğŸ§© Estrutura base:
Antes de tudo, o componente tem os seguintes estados:

const [nome, setNome] = useState("");
const [hora, setHora] = useState("");
const [remedios, setRemedios] = useState([]);
const [remedioEmEdicao, setRemedioEmEdicao] = useState(null);

ğŸ” O que cada um faz:
Estado            	FunÃ§Ã£o
nome	              Guarda o texto digitado no input de nome do remÃ©dio
hora	              Guarda o horÃ¡rio escolhido
remedios           	Ã‰ um array com todos os remÃ©dios cadastrados
                   (cada item Ã© um objeto com id, nome e hora)
remedioEmEdicaovvv	Guarda o id do remÃ©dio que estÃ¡ sendo editado. Quando estÃ¡ null, 
                   quer dizer que nÃ£o estamos editando nada.




ğŸ§± 1. Entendendo a funÃ§Ã£o prepararEdicao():
Essa funÃ§Ã£o Ã© chamada quando clicamos no botÃ£o â€œEditarâ€ de algum remÃ©dio:

function prepararEdicao(remedio) {
  setHora(remedio.hora);
  setNome(remedio.nome);
  setRemedioEmEdicao(remedio.id);
}

ğŸ§© Linha por linha:

1. setHora(remedio.hora)
â†’ Pega o valor da propriedade hora do objeto remedio e joga dentro do estado hora.
Isso faz com que o input <input type="time" value={hora} /> seja preenchido automaticamente 
com o horÃ¡rio do remÃ©dio.

2. setNome(remedio.nome)
â†’ Faz a mesma coisa para o nome.
Ou seja, os campos do formulÃ¡rio sÃ£o â€œpreenchidosâ€ automaticamente.

3. setRemedioEmEdicao(remedio.id)
â†’ Define qual remÃ©dio estamos editando, guardando o id dele.
Esse id Ã© Ãºnico e foi criado lÃ¡ na hora que adicionamos o remÃ©dio.
Se estivermos editando o item de id 3, por exemplo, o estado remedioEmEdicao vai virar 3.


ğŸ§  Analogia:
Pense assim:
quando vocÃª clica em â€œEditarâ€, o React pega aquele objeto do array e fala:

â€œOk, Mikael, agora vou colocar o nome e a hora desse item nos campos, e 
guardar o id dele pra saber que esse Ã© o cara que estamos mexendo.â€


ğŸ’¬ Sua dÃºvida sobre event.target.value

â€œChat, eu nÃ£o poderia usar event.target.value aqui?â€

NÃ£o.
O event.target.value sÃ³ existe dentro de eventos de input (quando o usuÃ¡rio digita algo).
No caso de prepararEdicao, vocÃª nÃ£o estÃ¡ pegando valor do input â€” estÃ¡ pegando valor de um objeto existente no array de remÃ©dios.
Ou seja: vocÃª nÃ£o precisa ler o que o usuÃ¡rio digitou, e sim preencher o campo com o que jÃ¡ estava no objeto.



âš™ï¸ 2. FunÃ§Ã£o principal: adicionarRemedio():
Essa Ã© a funÃ§Ã£o que controla tanto o adicionar quanto o editar.

function adicionarRemedio(event) {
  event.preventDefault();

  if (nome.trim() !== '' && hora.trim() !== '') {
    const id = remedioEmEdicao || Date.now();

    const novoMedicamento = { id, nome, hora };

    if (remedioEmEdicao) {
      setRemedios((listaAnterior) =>
        listaAnterior.map((remedio) =>
          remedio.id === remedioEmEdicao ? novoMedicamento : remedio
        )
      );
    } else {
      setRemedios((listaAnterior) => [...listaAnterior, novoMedicamento]);
    }

    setNome('');
    setHora('');
    setRemedioEmEdicao(null);
  }
}


ğŸ§© Entendendo o passo a passo:

1ï¸âƒ£ event.preventDefault()
Evita que o navegador recarregue a pÃ¡gina ao enviar o formulÃ¡rio.


2ï¸âƒ£ const id = remedioEmEdicao || Date.now();
Aqui acontece algo importante:
. Se estivermos editando (remedioEmEdicao tem um valor), ele usa o id existente.
. Se for um novo remÃ©dio, ele cria um id novo com Date.now().

ğŸ§  Isso garante que:
. EdiÃ§Ãµes mantÃªm o mesmo id.
. Novos itens ganham um id novo.


3ï¸âƒ£ Criando o novo objeto:
const novoMedicamento = { id, nome, hora };

Aqui estamos criando um novo objeto que representa o remÃ©dio (seja novo ou atualizado).
Exemplo:

{ id: 17397438493, nome: "Dipirona", hora: "09:00" }



4ï¸âƒ£ Se estamos editandoâ€¦
setRemedios((listaAnterior) =>
  listaAnterior.map((remedio) =>
    remedio.id === remedioEmEdicao ? novoMedicamento : remedio
  )
);


ğŸ§  Explicando passo a passo:

. setRemedios â†’ atualiza o estado remedios.
. (listaAnterior) â†’ Ã© o array atual de remÃ©dios (antes da mudanÃ§a).
Esse parÃ¢metro â€œherdaâ€ o valor do estado automaticamente.
. .map() â†’ percorre cada item do array.
. remedio.id === remedioEmEdicao â†’ verifica se o id atual Ã© o que estamos editando.
. ? novoMedicamento : remedio â†’ se for o mesmo id, substitui; se nÃ£o for, mantÃ©m igual.


ğŸ“˜ Exemplo:
Antes:

[
  { id: 1, nome: "Dipirona", hora: "08:00" },
  { id: 2, nome: "Paracetamol", hora: "10:00" }
]


Depois de editar o de id 1:

[
  { id: 1, nome: "Dipirona", hora: "09:00" },
  { id: 2, nome: "Paracetamol", hora: "10:00" }
]



5ï¸âƒ£ Se for um novo remÃ©dioâ€¦
setRemedios((listaAnterior) => [...listaAnterior, novoMedicamento]);


ğŸ§  Aqui usamos o spread operator (...):
. Ele copia todos os itens do estado anterior (listaAnterior).
. Depois adiciona o novo medicamento no final.

ğŸ“˜ Exemplo:
Antes:

[{ id: 1, nome: "Dipirona", hora: "08:00" }]


Depois:

[
  { id: 1, nome: "Dipirona", hora: "08:00" },
  { id: 2, nome: "Paracetamol", hora: "10:00" }
]

6ï¸âƒ£ Limpando os campos
setNome('');
setHora('');
setRemedioEmEdicao(null);


ğŸ§  Isso acontece depois de salvar (tanto ediÃ§Ã£o quanto adiÃ§Ã£o).

setNome('') e setHora('') limpam os inputs.

setRemedioEmEdicao(null) faz o sistema â€œesquecerâ€ que estÃ¡ editando.
Assim, o botÃ£o volta a mostrar â€œAdicionarâ€ em vez de â€œSalvar alteraÃ§Ãµesâ€.


ğŸ’­ null vs false:

Por que usamos null e nÃ£o false?
. null significa â€œnÃ£o tem valorâ€ (ou â€œnenhum item em ediÃ§Ã£oâ€).
. false Ã© um valor lÃ³gico, usado em condiÃ§Ãµes booleanas (verdadeiro/falso).
Aqui, nÃ£o estamos checando uma condiÃ§Ã£o lÃ³gica, e sim a ausÃªncia de um id â€” por isso null faz mais sentido.


ğŸ§  Entendendo a origem do id:
â€œMas, Chat, de onde vem esse id? Eu nÃ£o vi ele declarado!â€

| O id Ã© criado no momento em que o remÃ©dio Ã© adicionado:

const id = Date.now();

Ele Ã© um nÃºmero baseado na data e hora atual (em milissegundos).
Assim, cada remÃ©dio tem um id Ãºnico â€” e Ã© esse mesmo id que usamos depois para saber qual item editar.



ğŸ¨ 3. JSX resumido:
<form onSubmit={adicionarRemedio}>
  <input
    type="text"
    placeholder="Nome do remÃ©dio"
    value={nome}
    onChange={(e) => setNome(e.target.value)}
  />
  <input
    type="time"
    value={hora}
    onChange={(e) => setHora(e.target.value)}
  />
  <button type="submit">
    {remedioEmEdicao ? "Salvar ediÃ§Ã£o" : "Adicionar"}
  </button>
</form>

{remedios.map((remedio) => (
  <div key={remedio.id}>
    <p>{remedio.nome}</p>
    <p>{remedio.hora}</p>
    <button onClick={() => prepararEdicao(remedio)}>Editar</button>
  </div>
))}




ğŸ“˜ 4. O ciclo completo do editar:
. UsuÃ¡rio adiciona remÃ©dio â†’ entra no array.
. UsuÃ¡rio clica em â€œEditarâ€ â†’ campos sÃ£o preenchidos.
. UsuÃ¡rio muda o nome ou hora â†’ estados nome e hora atualizam.
. UsuÃ¡rio clica em â€œSalvar ediÃ§Ã£oâ€ â†’ item Ã© atualizado no estado.
. Campos limpam â†’ volta pro modo normal.



ğŸ§© 5. Resumo tÃ©cnico e prÃ¡tico:
Conceito	                      O que aprendeu
Inputs controlados	            Ligam diretamente o campo ao estado
Imutabilidade	                  Sempre cria um novo array com map ou [...]
Id Ãºnico	                      Garante que cada item possa ser identificado
Modo de ediÃ§Ã£o	                Controlado via remedioEmEdicao
Null vs False	                  null representa ausÃªncia, false representa valor lÃ³gico
event.target.value	            SÃ³ usado em eventos de input, nÃ£o pra preencher estados diretamente




ğŸ’¡ 6. Exemplo prÃ¡tico com campo extra (observaÃ§Ãµes):

Se vocÃª tivesse um novo campo, como â€œobservaÃ§Ãµesâ€, seria assim:

const [observacao, setObservacao] = useState('');

function prepararEdicao(remedio) {
  setNome(remedio.nome);
  setHora(remedio.hora);
  setObservacao(remedio.observacao || '');
  setRemedioEmEdicao(remedio.id);
}


E ao criar o novo medicamento:

const novoMedicamento = { id, nome, hora, observacao };

Percebe que basta incluir o novo campo no mesmo fluxo â€” a lÃ³gica nÃ£o muda.





ğŸ§© 7. ConclusÃ£o:

Essa feature ensina praticamente tudo o que um dev front-end precisa saber 
sobre React e manipulaÃ§Ã£o de estado:

âœ… Lidar com inputs controlados
âœ… Atualizar listas no estado de forma imutÃ¡vel
âœ… Criar e reaproveitar objetos dinamicamente
âœ… Usar map com operador ternÃ¡rio para atualizar itens especÃ­ficos
âœ… Entender o uso correto de null, false e event.target.value
âœ… E estruturar o cÃ³digo de forma limpa e reaproveitÃ¡vel


























.
ğŸ§© Aula completa â€” Sistema de sugestÃµes automÃ¡ticas de medicamentos
ğŸ¯ Objetivo da feature

Essa feature faz com que, enquanto o usuÃ¡rio digita o nome de um medicamento, o sistema exiba sugestÃµes automÃ¡ticas com base em um array de medicamentos jÃ¡ existentes.
Assim que o usuÃ¡rio clica em uma das sugestÃµes, o campo de nome Ã© preenchido automaticamente e a lista desaparece.

Essa funcionalidade melhora muito a experiÃªncia do usuÃ¡rio e evita erros de digitaÃ§Ã£o, alÃ©m de dar uma aparÃªncia mais inteligente ao sistema.



ğŸ§± Estrutura geral da feature:
Ela Ã© composta basicamente por trÃªs partes principais:

1. Um estado que guarda as sugestÃµes filtradas.
2. Um useEffect que contÃ©m toda a lÃ³gica de verificaÃ§Ã£o e filtragem conforme o usuÃ¡rio digita.
3. Uma renderizaÃ§Ã£o condicional que mostra ou esconde a lista de sugestÃµes conforme as condiÃ§Ãµes.



âš™ï¸ LÃ³gica principal com useEffect:

VersÃ£o final e melhorada do cÃ³digo:

useEffect(() => {
  const nomeSemEspacos = nome.trim(); // ğŸ”¹ remove espaÃ§os extras antes e depois do nome

  // ğŸ§© Caso o campo esteja vazio â†’ limpa as sugestÃµes e encerra a funÃ§Ã£o
  if (!nomeSemEspacos) {
    setSugestoes([]);
    return;
  }

  // ğŸ§  Verifica se o nome digitado jÃ¡ Ã© exatamente igual a algum medicamento existente
  const jaExisteMedicamento = medicamentos.some(
    (medicamento) =>
      medicamento.nome.toLowerCase() === nomeSemEspacos.toLowerCase()
  );

  // ğŸ”¸ Se for igual, nÃ£o precisa sugerir nada â†’ limpa as sugestÃµes
  if (jaExisteMedicamento) {
    setSugestoes([]);
    return;
  }

  // ğŸ” Filtra medicamentos que comecem com o texto digitado
  const sugestoesFiltradas = medicamentos.filter((medicamento) =>
    medicamento.nome.toLowerCase().startsWith(nomeSemEspacos.toLowerCase())
  );

  // ğŸ’¾ Atualiza o estado de sugestÃµes
  setSugestoes(sugestoesFiltradas);
}, [nome, medicamentos]);


ğŸ§  ExplicaÃ§Ã£o detalhada passo a passo:

- ğŸ”¹const nomeSemEspacos = nome.trim():

O mÃ©todo .trim() remove todos os espaÃ§os em branco no inÃ­cio e no fim da string.

ğŸ‘‰ Isso Ã© importante porque o usuÃ¡rio pode digitar "dipirona " (com espaÃ§o no final), 
e sem o .trim() o sistema consideraria "dipirona " diferente de "dipirona".
Assim, trim() evita erros bobos e garante que o filtro funcione corretamente.


- ğŸ”¹if (!nomeSemEspacos) { setSugestoes([]); return; }:

Aqui testamos se o campo de nome estÃ¡ vazio depois de remover os espaÃ§os.
Se estiver vazio, limpamos a lista de sugestÃµes e interrompemos a execuÃ§Ã£o com return.

. !nomeSemEspacos significa â€œse nomeSemEspacos for falsoâ€.
. Uma string vazia ("") Ã© considerada falsy no JavaScript.

ğŸ’¡ Por que fazer isso?
Se o usuÃ¡rio apagar tudo o que digitou, nÃ£o faz sentido mostrar sugestÃµes de medicamentos.



-ğŸ”¹const jaExisteMedicamento = medicamentos.some(...):

O .some() percorre o array de medicamentos e retorna true se pelo menos um item satisfizer a condiÃ§Ã£o.

Aqui, estamos verificando se o nome digitado jÃ¡ Ã© exatamente igual a um medicamento que existe na lista.

const jaExisteMedicamento = medicamentos.some(
  (medicamento) =>
    medicamento.nome.toLowerCase() === nomeSemEspacos.toLowerCase()
);


Usamos toLowerCase() para evitar diferenÃ§a entre letras maiÃºsculas e minÃºsculas.
Por exemplo: â€œDipironaâ€ e â€œdipironaâ€ devem ser tratados como iguais.

ğŸ’¡ Por que isso existe?
Se o nome digitado jÃ¡ for exatamente igual ao de um medicamento, nÃ£o faz sentido continuar exibindo sugestÃµes.
Isso evita que a lista continue aparecendo depois que o usuÃ¡rio jÃ¡ selecionou algo vÃ¡lido.



-ğŸ”¹const sugestoesFiltradas = medicamentos.filter(...):

O mÃ©todo .filter() percorre o array e retorna apenas os itens que passam na condiÃ§Ã£o.

const sugestoesFiltradas = medicamentos.filter((medicamento) =>
  medicamento.nome.toLowerCase().startsWith(nomeSemEspacos.toLowerCase())
);

Usamos startsWith() porque queremos pegar apenas os medicamentos que comeÃ§am com o texto digitado.
Se o usuÃ¡rio digitar â€œdiâ€, aparecerÃ£o â€œDipironaâ€, â€œDiclofenacoâ€, etc.

ğŸ’¡ DiferenÃ§a importante:
Se usÃ¡ssemos .includes() em vez de .startsWith(), ele retornaria qualquer nome 
que contivesse o texto â€” mesmo no meio da palavra.
Mas aqui o comportamento ideal Ã© aparecer somente os nomes que comeÃ§am com o texto digitado.



-ğŸ”¹setSugestoes(sugestoesFiltradas):

Atualiza o estado sugestoes com o resultado do filtro.
Isso dispara uma nova renderizaÃ§Ã£o no React, mostrando as sugestÃµes atualizadas na tela.

ğŸ§  ComparaÃ§Ã£o entre a versÃ£o antiga (com erro) e a versÃ£o atual (corrigida)
ğŸ”¸ Filtro de texto

VersÃ£o antiga: Usava diretamente o valor de nome.
Problema: NÃ£o removia espaÃ§os e comparava incorretamente.
VersÃ£o corrigida: Usa nome.trim().
SoluÃ§Ã£o: Remove espaÃ§os extras antes da comparaÃ§Ã£o.

ğŸ”¸ Condicional

VersÃ£o antiga: NÃ£o tratava o caso em que o nome digitado era idÃªntico a um jÃ¡ existente.
Problema: SugestÃµes continuavam aparecendo mesmo apÃ³s selecionar um nome igual.
VersÃ£o corrigida: Utiliza some() com toLowerCase().
SoluÃ§Ã£o: Garante que, se o nome jÃ¡ existir, as sugestÃµes sejam limpas.

ğŸ”¸ LÃ³gica de atualizaÃ§Ã£o

VersÃ£o antiga: Executava o filtro mesmo quando o campo estava vazio.
Problema: Apareciam sugestÃµes indevidas.
VersÃ£o corrigida: Adiciona if (!nomeSemEspacos) antes do filtro.
SoluÃ§Ã£o: Interrompe a execuÃ§Ã£o quando o campo estÃ¡ vazio.





ğŸ’¬ RenderizaÃ§Ã£o condicional no JSX
{(sugestoes.length > 0 && nome.trim()) && (
  <ul className="border border-gray-300 rounded mt-1 bg-white shadow">
    {sugestoes.map((s, index) => (
      <li
        key={index}
        onClick={() => {
          setNome(s.nome);
          setSugestoes([]);
        }}
        className="p-2 cursor-pointer hover:bg-blue-100"
      >
        {s.nome}
      </li>
    ))}
  </ul>
)}


Vamos entender cada parte:


-ğŸ”¹(sugestoes.length > 0 && nome.trim()) && (...):

Isso Ã© a renderizaÃ§Ã£o condicional com operador lÃ³gico &&.
Ã‰ a forma mais usada em React para exibir algo apenas quando uma condiÃ§Ã£o for verdadeira.

Funciona assim:
. Se sugestoes.length > 0 for true (ou seja, hÃ¡ pelo menos 1 sugestÃ£o)
. E nome.trim() for truthy (ou seja, o campo nÃ£o estÃ¡ vazio)
. EntÃ£o o React renderiza o conteÃºdo dentro dos parÃªnteses (a <ul> com as sugestÃµes).

Se qualquer uma dessas duas condiÃ§Ãµes for falsa â†’ nada Ã© renderizado.


ğŸ’¡ Ã‰ literalmente como escrever:

if (sugestoes.length > 0 && nome.trim()) {
  return <ul>...</ul>
}


-ğŸ”¹.map() â€” criando cada item da lista:
{sugestoes.map((s, index) => (
  <li key={index}> {s.nome} </li>
))}

O mÃ©todo .map() percorre o array sugestoes e cria um elemento JSX para cada item.
. s representa cada sugestÃ£o individual (um objeto do tipo { nome: "Dipirona" }).
. {s.nome} mostra o campo nome de cada sugestÃ£o.
. key={index} Ã© uma chave Ãºnica obrigatÃ³ria no React para listas (ajuda na renderizaÃ§Ã£o eficiente).
ğŸ’¡ Se vocÃª colocasse sÃ³ {s} em vez de {s.nome}, apareceria [object Object], porque s Ã© um objeto inteiro.


-ğŸ”¹onClick={() => { setNome(s.nome); setSugestoes([]); }}:

Esse trecho define o comportamento ao clicar em uma sugestÃ£o.
1. setNome(s.nome) â†’ preenche o campo de texto com o nome da sugestÃ£o clicada.
2. setSugestoes([]) â†’ limpa o array de sugestÃµes, fazendo a lista desaparecer.
ğŸ’¡ Sem essa segunda linha, as sugestÃµes continuariam aparecendo mesmo apÃ³s a seleÃ§Ã£o.

ğŸ§© Resumo dos principais mÃ©todos usados

trim() â†’ Remove espaÃ§os no inÃ­cio e no fim da string.
ğŸ“˜ Exemplo: " dipirona ".trim() â†’ "dipirona"

toLowerCase() â†’ Converte a string para minÃºsculas, garantindo que a comparaÃ§Ã£o nÃ£o falhe por 
causa de letras maiÃºsculas/minÃºsculas.
ğŸ“˜ Exemplo: "Dipirona".toLowerCase() â†’ "dipirona"

some() â†’ Verifica se pelo menos um elemento do array satisfaz a condiÃ§Ã£o passada. Retorna true ou false.
ğŸ“˜ Exemplo: [1, 2, 3].some(n => n > 2) â†’ true

filter() â†’ Retorna todos os elementos do array que atendem Ã  condiÃ§Ã£o.
ğŸ“˜ Exemplo: [1, 2, 3].filter(n => n > 2) â†’ [3]

startsWith() â†’ Verifica se uma string comeÃ§a com os caracteres informados.
ğŸ“˜ Exemplo: "dipirona".startsWith("di") â†’ true

map() â†’ Cria um novo array aplicando uma transformaÃ§Ã£o em cada elemento do array original.
ğŸ“˜ Exemplo: ["a", "b"].map(x => x.toUpperCase()) â†’ ["A", "B"]


ğŸ§­ Resumo mental da lÃ³gica:

1. O usuÃ¡rio digita algo â†’ o estado nome muda.
2. O useEffect Ã© ativado por causa da dependÃªncia [nome].
3. O sistema:
 . remove espaÃ§os (trim);
 . verifica se o campo estÃ¡ vazio (if (!nomeSemEspacos));
 . confere se o nome jÃ¡ existe (some);
 . filtra sugestÃµes que comeÃ§am com o texto (filter + startsWith);
 . atualiza sugestoes.
4. Se houver sugestÃµes â†’ React renderiza a <ul>.
5. UsuÃ¡rio clica em uma â†’ preenche o campo e limpa a lista.

âœ… ConclusÃ£o final
Essa feature ensina vÃ¡rios fundamentos importantes do React e JavaScript moderno:
. Estados e reatividade com useState e useEffect.
. RenderizaÃ§Ã£o condicional com &&.
. ManipulaÃ§Ã£o de arrays e strings (map, filter, some, trim, startsWith).
. Boas prÃ¡ticas de UX, como limpar sugestÃµes e evitar duplicaÃ§Ã£o de nomes.

Com essa base, vocÃª consegue replicar a mesma ideia em qualquer outro contexto â€”
por exemplo, auto-sugestÃµes de cidades, produtos, usuÃ¡rios, categorias, etc.




















ğŸ§  Aula: Feature â€” Adicionar Data e Hora ao Adicionar um Novo Medicamento
ğŸ¯ Objetivo da funcionalidade

Quando o usuÃ¡rio adiciona um novo remÃ©dio, o sistema deve registrar automaticamente a 
data e hora exata em que o medicamento foi adicionado, mostrando essa informaÃ§Ã£o 
junto com os dados do remÃ©dio.


ğŸ§© 1. Onde essa lÃ³gica entra no cÃ³digo:

A lÃ³gica foi implementada dentro da funÃ§Ã£o adicionarRemedio,
que Ã© executada quando o usuÃ¡rio clica em â€œAdicionarâ€.

Essa funÃ§Ã£o jÃ¡ criava um novo objeto novoMedicamento, e Ã© exatamente nesse ponto que 
incluÃ­mos a nova propriedade dataAdicao.




ğŸ’¡ 2. A criaÃ§Ã£o da data formatada:

Antes de montar o objeto do novo remÃ©dio, criamos a data e a hora atuais:

const agora = new Date(); // cria uma data com o momento atual
const dataFormatada = agora.toLocaleString("pt-BR", {
  day: "2-digit",
  month: "2-digit",
  year: "numeric",
  hour: "2-digit",
  minute: "2-digit",
});

ğŸ§  Explicando:

. new Date() â†’ cria um objeto com a data e hora atuais do sistema.
. toLocaleString("pt-BR", {...}) â†’ formata a data no padrÃ£o brasileiro (ex: 23/10/2025, 14:32).
. As opÃ§Ãµes passadas (day, month, year, hour, minute) garantem que o formato fique legÃ­vel.



ğŸ§± 3. Montando o objeto novoMedicamento com data e hora:

Abaixo estÃ¡ o trecho principal:

const novoMedicamento = medicamentoEncontrado
  ? { ...medicamentoEncontrado, hora, id, dataAdicao: dataFormatada }
  : { id, nome, hora, dosagem, observacao, dataAdicao: dataFormatada };

ğŸ§© Explicando o que acontece:
1. O operador ternÃ¡rio (? :) decide qual objeto criar:
. Se o remÃ©dio jÃ¡ existe no JSON (medicamentoEncontrado), ele copia 
os dados com o spread operator (...medicamentoEncontrado) e adiciona/atualiza os campos necessÃ¡rios.
. Se for um remÃ©dio novo, ele cria um novo objeto do zero.

2. Em ambos os casos, adicionamos:
jsx:
dataAdicao: dataFormatada

Ou seja, toda vez que um remÃ©dio for adicionado, serÃ¡ registrado com o 
campo dataAdicao contendo a data e hora da adiÃ§Ã£o.



ğŸ” 4. O operador ternÃ¡rio com objetos (detalhado):

Como o ternÃ¡rio retorna valores, vocÃª pode retornar qualquer tipo de dado â€” incluindo objetos.

ğŸ’¬ Exemplo simples:

const usuarioLogado = true;

const perfil = usuarioLogado
  ? { nome: "Mikael", status: "online" }
  : { nome: "Visitante", status: "offline" };

console.log(perfil);
// â†’ { nome: "Mikael", status: "online" }


ğŸ§© No nosso caso:
. Se encontrou o medicamento â†’ cria um objeto baseado nele.
. Se nÃ£o â†’ cria um novo objeto manualmente.
. Em ambos â†’ adiciona a propriedade dataAdicao.



ğŸ§° 5. Exibindo a data na interface:

Depois de adicionar a propriedade ao estado, basta mostrar no JSX:

<p className="text-sm text-gray-600">
  ğŸ“… Adicionado em: {remedio.dataAdicao}
</p>

Se o medicamento foi adicionado agora, vai aparecer algo como:

ğŸ“… Adicionado em: 23/10/2025 17:42




âš™ï¸ 6. Ciclo completo da lÃ³gica:
Etapa	                          O que acontece
ğŸŸ¢ 1.                          UsuÃ¡rio clica em â€œAdicionarâ€	Executa adicionarRemedio()
ğŸ•“ 2.                          Sistema cria new Date()	Gera data/hora atual
ğŸ§© 3.                          Formata data/hora	Deixa no formato dd/mm/aaaa hh:mm
ğŸ’¾ 4.                          Cria novoMedicamento com dataAdicao	Adiciona a nova propriedade ao objeto
ğŸ“¦ 5.                          Atualiza o estado remedios	O React re-renderiza a tela
ğŸ–¥ï¸ 6.                          Exibe na interface a data/hora	Mostra visualmente ao usuÃ¡rio



ğŸ§  7.Principais mÃ©todos usados:

MÃ©todo	                     O que faz	                          Exemplo
new Date()	                 Cria um objeto representando a       new Date() â†’ Thu Oct 23 2025 17:42:10 GMT...
                             data/hora atual.	
toLocaleString()	           Formata data/hora conforme o         new Date().toLocaleString("pt-BR")
                             idioma e opÃ§Ãµes.	                    â†’ "23/10/2025 17:42"
? : (ternÃ¡rio)	             Retorna um valor entre duas          condicao ? valor1 : valor2
                             opÃ§Ãµes conforme uma condiÃ§Ã£o.	
... (spread operator)	       Copia as propriedades de um objeto   { ...user, idade: 25 }
                             existente.	



âœ… 8. Resultado final:

Ao adicionar um remÃ©dio:
. Ele aparece na lista com a data e hora de adiÃ§Ã£o.
. O valor Ã© salvo junto aos outros dados (e mantido no localStorage tambÃ©m).
. Cada medicamento terÃ¡ seu prÃ³prio campo dataAdicao, registrado no momento exato da criaÃ§Ã£o.

ğŸ’¬ Resumo conceitual

Toda vez que adicionamos um novo item, podemos registrar 
metadados â€” informaÃ§Ãµes sobre o evento em si (como data/hora de criaÃ§Ã£o, ID, autor etc).
Essa prÃ¡tica Ã© muito usada em sistemas reais, porque ajuda a rastrear
quando as coisas foram criadas ou modificadas.





























.

ğŸ“˜ Aula Completa: Funcionalidade de HistÃ³rico de Medicamentos (VersÃ£o Inicial)
ğŸ§­ 1. Objetivo da funcionalidade

Essa funcionalidade registra cada medicamento adicionado na lista, permitindo que 
o usuÃ¡rio mantenha um histÃ³rico de adiÃ§Ãµes, mesmo apÃ³s fechar o aplicativo.

ğŸ¯ O que ela faz:
. Registra nome, dosagem, horÃ¡rio e data exata em que o remÃ©dio foi adicionado.
. MantÃ©m os dados persistentes no navegador via localStorage.
. Exibe uma lista completa com todos os medicamentos jÃ¡ adicionados.

ğŸ’¡ Importante:
Esta Ã© a versÃ£o inicial.
Ainda nÃ£o registra remoÃ§Ãµes, alarmes ou contagem regressiva, mas 
serve como base sÃ³lida para evoluir futuramente com:
. Registro de medicamentos tomados/removidos
. Filtros e ordenaÃ§Ã£o
. ExportaÃ§Ã£o do histÃ³rico




ğŸ§© 2. Estrutura geral da lÃ³gica:
1. O fluxo principal Ã© dividido em quatro etapas:
2. Estados e carregamento inicial (useState)
3. PersistÃªncia automÃ¡tica (useEffect)
4. FunÃ§Ã£o de adicionar medicamento (adicionarRemedio)



RenderizaÃ§Ã£o e exibiÃ§Ã£o do histÃ³rico (JSX):

âš™ï¸ 3. Estados iniciais e carregamento (useState)
DeclaraÃ§Ã£o dos estados:
const [remedios, setRemedios] = useState(() => {
  const salv = localStorage.getItem("dadosRemedios");
  return salv ? JSON.parse(salv) : [];
});

const [historico, setHistorico] = useState(() => {
  const salv = localStorage.getItem("historicoMedicamento");
  return salv ? JSON.parse(salv) : [];
});


ğŸ” Entendendo a lÃ³gica:
. useState aqui recebe uma funÃ§Ã£o de inicializaÃ§Ã£o.
Essa funÃ§Ã£o sÃ³ Ã© executada uma vez â€” quando o componente Ã© montado.
Isso evita ler o localStorage a cada renderizaÃ§Ã£o.

. localStorage.getItem("dadosRemedios"):
busca os remÃ©dios que estavam salvos da Ãºltima sessÃ£o.

. JSON.parse(salv):
converte o texto do localStorage de volta em um array de objetos JavaScript.

. Se nÃ£o encontrar nada (null), inicializa com [] (array vazio).




ğŸ’¡ DiferenÃ§a entre os estados:
Estado	                                 Finalidade
remedios                                 Lista ativa: o que o usuÃ¡rio adicionou e ainda estÃ¡ em uso
historico	                               Lista permanente: tudo o que jÃ¡ foi adicionado, 
                                         mesmo que depois seja removido


ğŸ” 4. PersistÃªncia automÃ¡tica (useEffect)

Cada lista tem seu prÃ³prio efeito de salvamento:

useEffect(() => {
  localStorage.setItem("dadosRemedios", JSON.stringify(remedios));
}, [remedios]);

useEffect(() => {
  localStorage.setItem("historicoMedicamento", JSON.stringify(historico));
}, [historico]);


ğŸ§  Por que separar?
Antes, talvez vocÃª tentasse salvar os dois estados num mesmo setItem, mas isso nÃ£o Ã© ideal.
O localStorage trabalha com chaves independentes â€” cada uma guarda apenas um valor.

EntÃ£o criamos dois useEffect separados, um para cada estado.
Assim:
. remedios salva com a chave "dadosRemedios"
. historico salva com a chave "historicoMedicamento"

âœ… Vantagens:
. Evita sobrescrever dados acidentalmente.
. Cada estado Ã© controlado de forma isolada.
. As listas persistem corretamente entre sessÃµes.



â• 5. FunÃ§Ã£o adicionarRemedio() â€” a lÃ³gica central
function adicionarRemedio(event) {
  event.preventDefault();

  if (!nome.trim() || !hora.trim() || !dosagem.trim()) return;

  const dataAtual = new Date();
  const dataFormatada = dataAtual.toLocaleString("pt-BR", {
    day: "2-digit",
    month: "2-digit",
    year: "numeric",
    hour: "2-digit",
    minute: "2-digit",
  });

  const id = Date.now(); // id Ãºnico baseado no timestamp

  const novoMedicamento = {
    id,
    nome,
    hora,
    dosagem,
    observacao,
    dataAdicaoAtual: dataFormatada,
  };

  setRemedios(prev => [...prev, novoMedicamento]);
  setHistorico(prev => [...prev, novoMedicamento]);

  setNome("");
  setHora("");
  setDosagem("");
  setObservacao("");
}

ğŸ” Passo a passo detalhado:

1. Prevenir o comportamento padrÃ£o do formulÃ¡rio com event.preventDefault(), 
para nÃ£o recarregar a pÃ¡gina.

2. ValidaÃ§Ã£o:
Se algum campo obrigatÃ³rio estiver vazio (!nome.trim() etc.), interrompe a funÃ§Ã£o com return.

3. Data e hora formatadas:
Usa new Date() e .toLocaleString("pt-BR") para gerar uma data no formato brasileiro, por exemplo:
28/10/2025 21:54.

4. ID Ãºnico:
Date.now() cria um nÃºmero baseado no timestamp atual (garante que cada remÃ©dio tenha um id exclusivo).

5. CriaÃ§Ã£o do objeto:
const novoMedicamento = { id, nome, hora, dosagem, observacao, dataAdicaoAtual }

Esse objeto representa um registro completo da adiÃ§Ã£o do remÃ©dio.

6. AtualizaÃ§Ã£o dos estados:

setRemedios(prev => [...prev, novoMedicamento]);
setHistorico(prev => [...prev, novoMedicamento]);

. O React atualiza estados de forma assÃ­ncrona, entÃ£o usamos o padrÃ£o 
prev => [...prev, novo] pra garantir que o novo valor Ã© adicionado sobre o anterior, 
sem sobrescrever.
. Assim, cada novo medicamento Ã© anexado Ã  lista existente, e nÃ£o substitui o conteÃºdo antigo.

7. Limpeza dos campos de input com os set vazios â€” isso prepara o formulÃ¡rio pro prÃ³ximo registro.



ğŸ–¥ï¸ 6. RenderizaÃ§Ã£o e interface do histÃ³rico (JSX):
<div className="mt-10 bg-white p-4 rounded shadow">
  <h2 className="text-2xl font-bold text-blue-700 mb-4">ğŸ“œ HistÃ³rico de Medicamentos</h2>
  {historico.length === 0 ? (
    <p className="text-gray-600">Nenhum medicamento adicionado ainda.</p>
  ) : (
    <ul>
      {historico.map((item) => (
        <li key={item.id} className="border-b border-gray-200 py-2">
          <strong>{item.nome}</strong> â€” {item.dosagem}  
          <br />
          â° {item.hora} | ğŸ“… {item.dataAdicaoAtual}
        </li>
      ))}
    </ul>
  )}
</div>

ğŸ§  O que acontece aqui:
. historico.length === 0 â†’ mostra mensagem amigÃ¡vel quando o histÃ³rico estÃ¡ vazio.
. historico.map() â†’ percorre todos os registros e renderiza um <li> pra cada medicamento.
. key={item.id} â†’ Ã© obrigatÃ³rio pro React identificar cada item da lista.
. Exibe as informaÃ§Ãµes de forma simples e direta, com Ã­cones e data formatada.



ğŸ§± 7. CÃ³digo base completo (resumo compacto):
// Estados
const [remedios, setRemedios] = useState(() => JSON.parse(localStorage.getItem("dadosRemedios")) || []);
const [historico, setHistorico] = useState(() => JSON.parse(localStorage.getItem("historicoMedicamento")) || []);

// Salvamento automÃ¡tico
useEffect(() => localStorage.setItem("dadosRemedios", JSON.stringify(remedios)), [remedios]);
useEffect(() => localStorage.setItem("historicoMedicamento", JSON.stringify(historico)), [historico]);

// AdiÃ§Ã£o
function adicionarRemedio(e) {
  e.preventDefault();
  if (!nome.trim() || !hora.trim() || !dosagem.trim()) return;

  const novoMedicamento = {
    id: Date.now(),
    nome,
    hora,
    dosagem,
    observacao,
    dataAdicaoAtual: new Date().toLocaleString("pt-BR"),
  };

  setRemedios(prev => [...prev, novoMedicamento]);
  setHistorico(prev => [...prev, novoMedicamento]);
  setNome(""); setHora(""); setDosagem(""); setObservacao("");
}



ğŸ§© 8. Erros comuns e soluÃ§Ãµes:
  Problema	                         Efeito observado	                             SoluÃ§Ã£o
. setHistorico(novo) ao invÃ©s de     HistÃ³rico sobrescreve e mostra sÃ³ o 	         Sempre usar funÃ§Ã£o com prev
prev => [...prev, novo]	             Ãºltimo registro
Chaves de localStorage trocadas	     Dados aparecem no localStorage mas nÃ£o        "dadosRemedios" e "historicoMedicamento"
                                     exibem no histÃ³rico	Usar nomes consistentes: 
Falta de useEffect para salvar	     HistÃ³rico some ao fechar o app	                Usar useEffect separado para cada estado
Renderizar histÃ³rico fora da         HistÃ³rico aparece â€œforaâ€ do layout visual	    Colocar dentro do mesmo container principal
hierarquia
Campos vazios	                       Adiciona itens incompletos	                    Validar com `if (!nome.trim()




ğŸ§  9. Entendendo a lÃ³gica interna (em palavras):
. Quando o app carrega, ele busca o que estava salvo no localStorage e repassa pro estado.
. Quando o usuÃ¡rio adiciona um remÃ©dio, o app:
  1. Cria o objeto completo do remÃ©dio.
  2. Adiciona esse objeto tanto Ã  lista principal quanto ao histÃ³rico.
  3. O React atualiza o estado â†’ o useEffect detecta a mudanÃ§a â†’ o localStorage Ã© atualizado.
. O histÃ³rico entÃ£o Ã© renderizado automaticamente com os dados mais recentes.
. Se recarregar a pÃ¡gina, o useState inicial recupera tudo salvo.




ğŸ’¡ 10. Principais aprendizados tÃ©cnicos:
Conceito	                              ExplicaÃ§Ã£o
FunÃ§Ã£o no useState	                    Executa sÃ³ uma vez â€” Ã³tima pra inicializar dados do localStorage.
Dois useEffect separados	              Evita conflito e garante salvamento correto de cada estado.
setState(prev => [...prev, novo])	      Adiciona novos itens sem sobrescrever os anteriores.
localStorage como cache local	          Garante persistÃªncia entre sessÃµes sem backend.
toLocaleString("pt-BR")	                Facilita exibiÃ§Ã£o de data/hora no formato brasileiro.




ğŸ ConclusÃ£o:
Essa Ã© a primeira versÃ£o funcional e estÃ¡vel do histÃ³rico de medicamentos.
Ela resolve a base de registro de aÃ§Ãµes e persistÃªncia de dados, servindo de 
fundaÃ§Ã£o para as prÃ³ximas funcionalidades como contagem regressiva e alarmes.





































ğŸ§­ Aula 1 â€” Como criar uma contagem regressiva com React passo a passo
ğŸ¯ Objetivo

Aprender a criar uma contagem regressiva funcional no React, entendendo cada etapa 
do cÃ³digo â€” desde os estados, funÃ§Ãµes e efeitos colaterais atÃ© a formataÃ§Ã£o final do tempo.

A ideia Ã© que, ao final, vocÃª consiga reproduzir e adaptar esse cronÃ´metro em qualquer projeto.

ğŸ§© Parte 1 â€” Criando os estados principais

No React, usamos useState para armazenar valores que mudam ao longo do tempo â€” e que, 
quando mudam, fazem a interface atualizar automaticamente.

const [duracaoEmHoras, setDuracaoEmHoras] = useState(0);
const [milissegundosConvertidos, setMilissegundosConvertidos] = useState(0);
const [tempoRestante, setTempoRestante] = useState(0);
const [contando, setContando] = useState(false);

ğŸ§  Explicando cada um:
. duracaoEmHoras â†’ quanto tempo (em horas) o usuÃ¡rio quer contar.
. milissegundosConvertidos â†’ o valor de horas convertido em milissegundos (ms).
. tempoRestante â†’ o tempo que ainda falta, tambÃ©m em milissegundos.
. contando â†’ indica se o cronÃ´metro estÃ¡ ativo (true) ou parado (false).

Esses estados sÃ£o a base do nosso contador.



â±ï¸ Parte 2 â€” Criando o botÃ£o de inÃ­cio/parada:

Podemos ter um botÃ£o que inicie e pare a contagem:

function alternarContagem() {
  setContando(!contando);
}


ğŸ§  ExplicaÃ§Ã£o:
. Esse cÃ³digo inverte o valor de contando.
Se estava false, vira true, e vice-versa.
Assim conseguimos iniciar e pausar o cronÃ´metro.




â²ï¸ Parte 3 â€” Convertendo horas para milissegundos:

Antes de comeÃ§ar a contagem, precisamos transformar o valor em 
milissegundos, porque o setInterval trabalha com essa unidade.

function converterDuracaoParaMs() {
  const ms = duracaoEmHoras * 60 * 60 * 1000;
  setMilissegundosConvertidos(ms);
  setTempoRestante(ms);
}

ğŸ” Explicando passo a passo
Etapa                    	ConversÃ£o           	    CÃ¡lculo         	Resultado
1	                       1 hora â†’ minutos      	    1 Ã— 60	          60 minutos
2	                       1 minuto â†’ segundos	      60 Ã— 60	          3600 segundos
3	                       1 segundo â†’ milissegundos	3600 Ã— 1000	      3.600.000 ms

âœ… 1 hora = 3.600.000 milissegundos

Se forem 2 horas, basta multiplicar:
2 Ã— 3.600.000 = 7.200.000 ms


ğŸ§  Entendendo a funÃ§Ã£o:
. duracaoEmHoras * 60 * 60 * 1000 â†’ converte o valor digitado (em horas) 
para milissegundos.
. setMilissegundosConvertidos(ms) â†’ guarda esse valor convertido.
. setTempoRestante(ms) â†’ define o tempo inicial da contagem.

ğŸ’¬ Resumindo:
â€œSe o usuÃ¡rio digitar 1 hora, o React vai entender isso como 3.600.000 milissegundos.â€





â³ Parte 4 â€” Criando o efeito colateral (useEffect + setInterval):

Agora que temos o tempo, precisamos fazer ele diminuir de 1 em 1 segundo.
Pra isso usamos o useEffect, que cria um â€œefeito colateralâ€: algo que acontece automaticamente quando um valor muda.

useEffect(() => {
  if (contando) {
    const intervalo = setInterval(() => {
      setTempoRestante((valorAtual) => {
        if (valorAtual <= 1000) {
          clearInterval(intervalo);
          setContando(false);
          return 0;
        }
        return valorAtual - 1000;
      });
    }, 1000);

    return () => clearInterval(intervalo);
  }
}, [contando, tempoRestante]);



âš™ï¸ Explicando passo a passo:

1ï¸âƒ£ if (contando)

O intervalo sÃ³ deve rodar se o contador estiver ativo.

2ï¸âƒ£ setInterval(() => { ... }, 1000)

O setInterval executa uma funÃ§Ã£o a cada X milissegundos.
Aqui, a cada 1000 ms (1 segundo).

ğŸ“˜ Estrutura bÃ¡sica:

setInterval(() => {
  // cÃ³digo repetido a cada intervalo
}, tempoEmMs);


ğŸ§© Por que o nome â€œIntervalâ€?
Porque ele repete algo em intervalos de tempo fixos.
Pense: â€œExecute essa funÃ§Ã£o de segundo em segundoâ€.


ğŸ’¡ ComparaÃ§Ã£o com setTimeout
FunÃ§Ã£o	                 O que faz	                              Executa quantas vezes
setTimeout()             Executa uma vez apÃ³s um tempo	          1 vez
setInterval()          	 Executa vÃ¡rias vezes no mesmo intervalo	infinitamente (atÃ© parar)



3ï¸âƒ£ O cÃ¡lculo interno:

Dentro do setInterval, usamos:

setTempoRestante((valorAtual) => {
  if (valorAtual <= 1000) {
    clearInterval(intervalo);
    setContando(false);
    return 0;
  }
  return valorAtual - 1000;
});


ğŸ§  Entendendo:
. O React nos dÃ¡ o valorAtual do estado (tempoRestante).
. Se o tempo for menor ou igual a 1000 ms (1 segundo), ele:
  . para o intervalo com clearInterval(intervalo);
  . interrompe a contagem (setContando(false));
  . e retorna 0 (pra zerar o contador).
. Caso contrÃ¡rio, ele subtrai 1000 ms (1 segundo).

Ou seja, a cada segundo, o valor Ã© reduzido em 1000 atÃ© chegar a zero.


4ï¸âƒ£ return () => clearInterval(intervalo):

Essa Ã© a funÃ§Ã£o de limpeza.
Ela roda automaticamente quando o useEffect for reexecutado ou desmontado.

ğŸ§© Por que Ã© importante?
Pra evitar mÃºltiplos intervalos rodando ao mesmo tempo, o que geraria bugs ou contagens duplicadas.

5ï¸âƒ£ DependÃªncias [contando, tempoRestante]

O React vai observar essas variÃ¡veis.
Sempre que elas mudarem, o efeito serÃ¡ reavaliado â€” garantindo que o contador pare, reinicie ou continue corretamente.

ğŸ’¡ Exemplo completo de setInterval + clearInterval
const id = setInterval(() => {
  console.log("Executando...");
}, 1000);

setTimeout(() => {
  clearInterval(id);
  console.log("Parou o intervalo!");
}, 5000);


ğŸ§  O que acontece:
. A cada segundo, aparece â€œExecutando...â€
. ApÃ³s 5 segundos, o setTimeout executa e interrompe o intervalo.




ğŸ§® Parte 5 â€” Convertendo o tempo em formato legÃ­vel:

Queremos mostrar algo como:
00:01:23 â†’ (0 horas, 1 minuto e 23 segundos).

function formatarTempo(ms) {
  const totalSegundos = Math.floor(ms / 1000);
  const horas = Math.floor(totalSegundos / 3600);
  const minutos = Math.floor((totalSegundos % 3600) / 60);
  const segundos = totalSegundos % 60;

  return `${horas.toString().padStart(2, "0")}:${minutos
    .toString()
    .padStart(2, "0")}:${segundos.toString().padStart(2, "0")}`;
}





ğŸ”¹ Passo 1 â€” ms / 1000:

Converte milissegundos para segundos.

ms	                 /1000	                segundos
1000	               1000 / 1000 =          1	1s
2000	               2000 / 1000 =          2	2s
5000	               5000 / 1000 = 5	      5s
60000	               60000 / 1000 = 60	    60s = 1 min

ğŸ“˜ ConclusÃ£o:
Dividir por 1000 muda a unidade de tempo.
Ã‰ o mesmo que dividir centÃ­metros por 100 para virar metros.




ğŸ”¹ Passo 2 â€” totalSegundos / 3600:

Converte segundos em horas.

ğŸ’­ Por que 3600?
. 1 hora = 60 minutos
. 1 minuto = 60 segundos
ğŸ‘‰ 60 Ã— 60 = 3600 segundos por hora

ğŸ“˜ Exemplo:

const totalSegundos = 7200;
const horas = Math.floor(totalSegundos / 3600); // 2 horas


7200 / 3600 = 2 â†’ ou seja, duas horas completas.




ğŸ”¹ Passo 3 â€” O operador % (resto da divisÃ£o):

O operador % pega o que sobra de uma divisÃ£o.

Exemplo:
10 % 3 = 1


Porque:
3 cabe 3 vezes em 10 â†’ 3Ã—3=9
Sobra 1.

Agora aplicando ao tempo:
const minutos = Math.floor((totalSegundos % 3600) / 60);


ğŸ“˜ Exemplo com 3723 segundos:
1ï¸âƒ£ 3723 % 3600 = 123 â†’ sobram 123 segundos
2ï¸âƒ£ 123 / 60 = 2.05 â†’ arredondando pra baixo â†’ 2 minutos
3ï¸âƒ£ 123 % 60 = 3 â†’ sobram 3 segundos



ğŸ’¡ Resultado final:
1 hora, 2 minutos e 3 segundos

ğŸ”¹ Passo 4 â€” Formatando o texto final
.toString()

Transforma um nÃºmero em texto (string).

const numero = 9;
numero.toString(); // "9"

.padStart(2, "0")

Preenche o texto atÃ© ele ter 2 dÃ­gitos, com â€œ0â€ Ã  esquerda.

Exemplo	Resultado:
"5".padStart(2, "0")	"05"
"9".padStart(2, "0")	"09"
"12".padStart(2, "0")	"12"

ğŸ’¬ Start = inÃ­cio â†’ adiciona Ã  esquerda.
Existe tambÃ©m .padEnd() â†’ adiciona Ã  direita.

ğŸ’¡ Juntando tudo
return `${horas.toString().padStart(2, "0")}:${minutos
  .toString()
  .padStart(2, "0")}:${segundos.toString().padStart(2, "0")}`;


Isso garante que o formato fique sempre HH:MM:SS, mesmo se tiver sÃ³ um dÃ­gito:
00:01:07
01:00:00



ğŸ§  Resumo final:
Parte                     	ExplicaÃ§Ã£o simples
/ 1000	                    Converte milissegundos â†’ segundos
/ 3600	                    Converte segundos â†’ horas
/ 60	                      Converte segundos â†’ minutos
%	                          Pega o resto da divisÃ£o
Math.floor()	              Arredonda pra baixo
toString()	                Transforma nÃºmero em texto
padStart(2, "0")	          Garante 2 dÃ­gitos com zero Ã  esquerda





ğŸ’» Parte 5 â€” Estrutura JSX (exibiÃ§Ã£o da contagem regressiva)

Depois de criarmos toda a lÃ³gica, precisamos renderizar o contador na tela.
Essa Ã© a parte responsÃ¡vel pela interaÃ§Ã£o com o usuÃ¡rio: onde ele 
 define a duraÃ§Ã£o e vÃª o tempo sendo reduzido em tempo real â³

<label htmlFor="duracao" className="py-2 font-bold text-lg">
  DuraÃ§Ã£o (horas)
</label>

<input
  id="duracao"
  type="number"
  min="0"
  step="0.25"
  placeholder="Ex: 8 ou 1.5"
  value={duracaoEmHoras}
  onChange={(e) => setDuracaoEmHoras(e.target.value)}
  className="w-full p-2 border border-gray-300 rounded"
/>

<p className="mt-4 text-xl font-bold">
  Tempo restante:{" "}
  {tempoRestante > 0
    ? formatarTempo(tempoRestante)
    : "â° Tempo esgotado!"}
</p>

<button
  type="button"
  onClick={iniciarContagem}
  className="bg-green-600 text-white px-3 py-1 rounded hover:bg-green-700"
>
  Iniciar contagem
</button>

ğŸ§  Entendendo o JSX

ğŸ”¹ Label e Input:
. O label serve para identificar o campo de entrada.
. O input Ã© do tipo number, permitindo que o usuÃ¡rio digite as horas de duraÃ§Ã£o.
. O atributo step="0.25" permite valores fracionados (como 1.5 horas).
. O valor digitado Ã© armazenado no estado duracaoEmHoras com o onChange.

ğŸ”¹ ParÃ¡grafo (p):
. Exibe o tempo restante formatado usando nossa funÃ§Ã£o formatarTempo.
. Quando tempoRestante chega a zero, mostra automaticamente â€œâ° Tempo esgotado!â€.

ğŸ”¹ BotÃ£o:
. Dispara a funÃ§Ã£o iniciarContagem, que faz a conversÃ£o, inicia o setInterval e ativa a contagem.
. O estilo muda a cor no hover e usa tons de verde para indicar â€œinÃ­cioâ€.

ğŸ’¡ Dica prÃ¡tica

Para testar rapidamente:
1. Digite por exemplo 0.001 horas (â‰ˆ 3,6 segundos).
2. Clique em Iniciar contagem.
3. Veja o contador descendo e, quando chegar a 0, aparecer â€œâ° Tempo esgotado!â€.

-->
