<!--
.

ğŸ“ Aula: Salvando e carregando dados com localStorage no React (versÃ£o final)

1ï¸âƒ£ O que Ã© localStorage?
. Ã‰ um recurso do navegador que guarda dados no prÃ³prio computador do usuÃ¡rio.
. Diferente de um banco de dados, sÃ³ guarda strings (texto).
. Os dados continuam lÃ¡ mesmo se o usuÃ¡rio fechar ou recarregar a pÃ¡gina.

Exemplo simples no console:
localStorage.setItem('nome', 'Mikael'); // salvar
localStorage.getItem('nome');           // "Mikael"


2ï¸âƒ£ Por que usamos JSON.stringify e JSON.parse?
. O localStorage sÃ³ aceita texto.
. Nosso estado remedios Ã© um array de objetos.
. Precisamos converter para string para salvar, e converter de volta para objeto para usar.

JSON.stringify(remedios) // transforma array/objeto em string JSON
JSON.parse(string)       // transforma string JSON de volta em array/objeto



3ï¸âƒ£ A lÃ³gica no React:
const [remedios, setRemedios] = useState(() => {
  const dadosSalvos = localStorage.getItem('remedios');
  return dadosSalvos ? JSON.parse(dadosSalvos) : [];
});

useEffect(() => {
  localStorage.setItem("remedios", JSON.stringify(remedios));
}, [remedios]);



4ï¸âƒ£ Por que usamos useState(() => {...}) com funÃ§Ã£o inicial?
. O React sÃ³ executa essa funÃ§Ã£o na primeira renderizaÃ§Ã£o.
. Com isso, ele lÃª do localStorage uma Ãºnica vez e jÃ¡ inicializa remedios com o que estava salvo.
. Sem essa funÃ§Ã£o, vocÃª precisaria de dois useEffect: um para carregar e outro para salvar.
. Assim, tudo fica mais limpo.



5ï¸âƒ£ O operador ternÃ¡rio (condiÃ§Ã£o ? valor1 : valor2):

Dentro do useState usamos:
return dadosSalvos ? JSON.parse(dadosSalvos) : [];


Isso significa:
. Se dadosSalvos existe â†’ converte e retorna os dados.
. Se nÃ£o existe â†’ retorna um array vazio.


Ã‰ um jeito curto de escrever:
if (dadosSalvos) {
  return JSON.parse(dadosSalvos);
} else {
  return [];
}



6ï¸âƒ£ O que significa o [remedios] no useEffect?
. Ã‰ a lista de dependÃªncias.
. O React sÃ³ roda o useEffect de novo quando algo dessa lista muda.
. Colocando [remedios] â†’ ele roda sempre que remedios mudar.
. Se deixasse [], rodaria sÃ³ uma vez no inÃ­cio.



7ï¸âƒ£ Detalhes do localStorage:
. O localStorage.setItem recebe 2 parÃ¢metros:
. Chave: nome do item (string) â†’ 'remedios'.
. Valor: o que quer salvar (tambÃ©m string).

EntÃ£o:
localStorage.setItem('remedios', JSON.stringify(remedios))

. "remedios" Ã© a chave.
. JSON.stringify(remedios) Ã© o valor salvo (string).


Para ler:
localStorage.getItem('remedios')

. Retorna a string. Se quiser o array de volta, faz:
. JSON.parse(localStorage.getItem('remedios'))



8ï¸âƒ£ Resumo do fluxo
. PÃ¡gina abre â†’ useState lÃª localStorage e preenche remedios.
. UsuÃ¡rio adiciona um remÃ©dio â†’ setRemedios atualiza o estado.
. useEffect detecta mudanÃ§a em remedios â†’ salva os novos dados no localStorage.
. Se recarregar a pÃ¡gina â†’ useState pega os dados salvos e carrega de volta.


9ï¸âƒ£ Vantagens dessa abordagem
. NÃ£o precisa banco de dados para coisas simples.
. Os dados ficam sempre atualizados sem funÃ§Ãµes extras.
. Estado inicial jÃ¡ vem com os dados salvos (sem â€œflashâ€ vazio).
. Evita ter dois useEffect brigando entre si.


ğŸ’¡ Resumo em uma frase:
â€œO localStorage Ã© um armÃ¡rio do navegador.
Usamos useState para pegar o que estÃ¡ dentro quando o app carrega,
e useEffect para guardar tudo de novo sempre que algo mudar.â€
















ğŸ“š Aula: Listagem de Medicamentos no React

1. O objetivo da feature:

O que querÃ­amos com essa branch era:
. âœ… Ler um arquivo JSON (medicamentos.json) com dados de medicamentos (nome, dose, frequÃªncia, horÃ¡rio etc.).
. âœ… Exibir esses dados automaticamente na tela, sem que o usuÃ¡rio precise cadastrar.
. âœ… Deixar esses dados separados da lÃ³gica principal, ou seja, mantÃª-los no JSON em vez de hardcodar dentro do componente.



2. Preparando os estados:
No React usamos estados (useState) para guardar informaÃ§Ãµes que mudam durante a execuÃ§Ã£o da aplicaÃ§Ã£o.

No comeÃ§o do componente criamos dois estados:

const [remedios, setRemedios] = useState([]); 
const [medicamentos, setMedicamentos] = useState([]);

. remedios â†’ armazena os medicamentos que o usuÃ¡rio adiciona manualmente no formulÃ¡rio.
. medicamentos â†’ armazena os medicamentos que vÃªm do arquivo JSON.

Assim conseguimos trabalhar separadamente com cada fonte de dados.



3. Buscando o JSON com useEffect

Para carregar os dados assim que a pÃ¡gina abre, usamos o hook useEffect.

useEffect(() => {
  fetch("/medicamentos.json")
    .then((res) => res.json())
    .then((data) => setMedicamentos(data))
    .catch((error) =>
      console.log("Erro ao carregar medicamentos", error)
    );
}, []);

ExplicaÃ§Ã£o:
. fetch("/medicamentos.json") â†’ faz a requisiÃ§Ã£o para o arquivo JSON.
. .then(res => res.json()) â†’ transforma a resposta em um objeto JavaScript.
. .then(data => setMedicamentos(data)) â†’ guarda esses dados no estado medicamentos.
. catch(...) â†’ captura possÃ­veis erros.
. O [] no final garante que isso sÃ³ rode uma vez, quando o componente for montado.



4. Renderizando os medicamentos:

Depois que o JSON foi carregado no estado medicamentos, basta percorrer esse array com .map() e renderizar na tela.

<div className="mt-10">
  <ul>
    {medicamentos.map((medicamento) => (
      <li key={medicamento.id}>
        <strong>
          {medicamento.nome} - {medicamento.dose}
        </strong>{" "}
        <br />
        horÃ¡rio: {medicamento.horario} - frequÃªncia:{" "}
        {medicamento.frequencia}
      </li>
    ))}
  </ul>
</div>


O que acontece aqui:
. medicamentos.map(...) â†’ percorre cada item do array.
. key={medicamento.id} â†’ cada item precisa de uma chave Ãºnica.
. Dentro do JSX mostramos nome, dose, horÃ¡rio e frequÃªncia.
. Ou seja, sempre que o arquivo JSON mudar, a interface automaticamente vai refletir esses dados.



5. IntegraÃ§Ã£o com a lÃ³gica jÃ¡ existente:
Antes, nosso app sÃ³ cadastrava manualmente com o formulÃ¡rio (remedios).
Agora temos duas listas:

. Lista de remÃ©dios cadastrados pelo usuÃ¡rio
. Lista de medicamentos vindos do JSON

Assim a aplicaÃ§Ã£o mostra tanto o que o usuÃ¡rio digitou quanto o que jÃ¡ estava registrado no â€œbancoâ€ de medicamentos.



6. Por que isso Ã© importante?
. ğŸ“‚ SeparaÃ§Ã£o de responsabilidades â†’ os dados ficam em um arquivo externo (JSON).
. âš¡ ReutilizaÃ§Ã£o â†’ podemos mudar o JSON sem alterar o cÃ³digo.
. ğŸ”„ Dinamicidade â†’ se o JSON for atualizado, a interface tambÃ©m Ã©.
. ğŸ’» PrÃ³xima evoluÃ§Ã£o â†’ no futuro, esse fetch pode vir de uma API real, sem mudar muita coisa no cÃ³digo.


ğŸš€ ConclusÃ£o

Na branch listagem-medicamento, aprendemos:
1. Como usar useState para armazenar dados vindos de diferentes fontes.
2. Como usar useEffect + fetch para buscar dados de um JSON.
3. Como percorrer arrays com .map() para renderizar listas no React.
4. Como separar a lÃ³gica de medicamentos cadastrados manualmente e carregados automaticamente.

Isso fecha a funcionalidade de listar medicamentos.

Na prÃ¡tica, vocÃª agora tem:
. Um mini banco de dados local (JSON).
. IntegraÃ§Ã£o desse â€œbancoâ€ com React.
. ExibiÃ§Ã£o dinÃ¢mica dos dados.
























ğŸ”¹ 1. git checkout develop

Esse comando faz vocÃª entrar na branch develop.

Se jÃ¡ estiver nela, o Git responde algo como Already on 'develop'.

ğŸ”¹ 2. git merge main

Aqui Ã© onde sempre rola confusÃ£o ğŸ‘€

Esse comando pega o histÃ³rico da main e junta dentro da develop.

Ou seja: vocÃª estÃ¡ atualizando a develop com tudo que jÃ¡ existe na main.

NÃ£o Ã© o contrÃ¡rio. A main nÃ£o recebe nada aqui.

ğŸ“Œ EntÃ£o:

Branch ativa (onde vocÃª estÃ¡) = quem vai ser atualizada.

Branch do merge (que vocÃª passa como argumento) = quem traz as mudanÃ§as.

ğŸ‘‰ Como vocÃª estava em develop, o merge significa:

"junte as mudanÃ§as da main dentro da develop".

ğŸ”¹ 3. O que Ã© merge

Exatamente: merge = juntar o histÃ³rico de duas branches.
Ele cria um commit especial (merge commit) se houver diferenÃ§as entre elas.
Se nÃ£o houver conflitos, o Git une automaticamente.

ğŸ“Œ Se houver conflitos, vocÃª precisa resolver manualmente (como aconteceu antes).

ğŸ”¹ 4. git push origin develop

O push envia a sua branch local (develop) pro repositÃ³rio remoto (GitHub, GitLab etc.).

origin = apelido padrÃ£o pro repositÃ³rio remoto.

develop = branch que vocÃª estÃ¡ enviando.

ğŸ’¡ Se vocÃª sÃ³ fizesse o merge localmente e nÃ£o desse o push, a develop remota ficaria desatualizada.
O push origin develop garante que a branch remota fique igual Ã  sua local.




âœ… Resumindo sua explicaÃ§Ã£o corrigida:
. checkout develop â†’ entro na branch develop.
. merge main â†’ atualizo develop com tudo que estÃ¡ na main.
. push origin develop â†’ envio a develop atualizada pro GitHub.


















ğŸ§  Aula: Criando a funcionalidade Remover RemÃ©dio
ğŸ¯ Objetivo:

Permitir que o usuÃ¡rio remova um remÃ©dio da lista exibida na tela, de forma dinÃ¢mica, sem precisar recarregar a pÃ¡gina.

ğŸ§© Etapas de implementaÃ§Ã£o
1ï¸âƒ£ Entendimento do problema

QuerÃ­amos que cada remÃ©dio adicionado tivesse um botÃ£o de remover.
Quando o usuÃ¡rio clicasse, aquele remÃ©dio deveria sumir da lista imediatamente.

Pra isso, precisarÃ­amos:
. Acessar o estado atual da lista de remÃ©dios (remedios);
. Remover apenas o item selecionado, sem alterar o resto;
. Atualizar o estado pra refletir essa mudanÃ§a na interface 
(React faz isso automaticamente quando o estado muda).



2ï¸âƒ£ Criando a funÃ§Ã£o de remover

Usamos o React Hook useState que controla a lista de remÃ©dios:

const [remedios, setRemedios] = useState([]);


Depois criamos a funÃ§Ã£o removerRemedio:

function removerRemedio(idDoRemedio) {
  setRemedios((listaAnteriorDeRemedios) => 
    listaAnteriorDeRemedios.filter((remedio) => remedio.id !== idDoRemedio)
  );
}

ğŸ§© Explicando linha por linha:
. setRemedios(...) â†’ Ã© a funÃ§Ã£o que atualiza o estado remedios.
. (listaAnteriorDeRemedios) â†’ Ã© o estado antigo (a lista antes da remoÃ§Ã£o).
Esse nome Ã© sÃ³ pra clareza. Em alguns cÃ³digos aparece como prev, que Ã© 
abreviaÃ§Ã£o de previous, ou seja, â€œanteriorâ€.
. .filter() â†’ cria uma nova lista, sem modificar a original, mantendo apenas 
os elementos que passam no teste.
. (remedio) => remedio.id !== idDoRemedio â†’ esse Ã© o teste: sÃ³ ficam na lista os 
remÃ©dios cujo id nÃ£o Ã© igual ao id que queremos remover.
. O React entÃ£o re-renderiza o componente mostrando a nova lista, jÃ¡ sem o remÃ©dio removido.



3ï¸âƒ£ Ligando o botÃ£o Ã  funÃ§Ã£o:

Dentro do map() que mostra os remÃ©dios na tela, adicionamos um botÃ£o:

<button
  onClick={() => removerRemedio(remedio.id)}
  className="mt-2 bg-red-500 text-white px-3 py-1 rounded hover:bg-red-600"
>
  Remover
</button>

ğŸ§© O que acontece aqui:
. O onClick chama a funÃ§Ã£o removerRemedio, passando o id do remÃ©dio.
. Assim que o botÃ£o Ã© clicado, a funÃ§Ã£o roda e o item some da tela.



4ï¸âƒ£ Testando a funcionalidade:

Passos testados:
1. Adicionar 2 ou mais remÃ©dios.
2. Clicar em â€œRemoverâ€ em um deles.
3. Verificar se apenas aquele sumiu da lista.
4. Conferir se o resto da lista continua igual. âœ…

ğŸ§¹ Resultado final (resumo visual)
function removerRemedio(idDoRemedio) {
  setRemedios((listaAnterior) =>
    listaAnterior.filter((remedio) => remedio.id !== idDoRemedio)
  );
}



ğŸ’¡ Resumo conceitual:
.filter() percorre a lista e cria uma nova, com todos os itens que 
nÃ£o tÃªm o ID igual ao que queremos remover.
Depois setRemedios atualiza o estado com essa nova lista.
O React automaticamente refaz a renderizaÃ§Ã£o â€” e o item desaparece da tela.


ğŸ“š ConclusÃ£o
. Usamos o conceito de imutabilidade do React: nunca alteramos o 
estado direto, sempre criamos uma nova lista.
. Entendemos o uso do callback no setState, pra trabalhar com o 
valor anterior de forma segura.
. Aplicamos o .filter(), uma funÃ§Ã£o nativa do JavaScript muito 
usada pra manipular arrays no React.



























ğŸ§  Aula Completa â€“ Funcionalidade â€œEditar RemÃ©dioâ€ no React

ğŸ“˜ Objetivo:
Permitir que o usuÃ¡rio adicione, edite e atualize remÃ©dios sem criar duplicaÃ§Ãµes, 
mantendo o estado da lista atualizado em tempo real.
Essa funcionalidade representa o â€œUâ€ do CRUD (Update) â€” atualizar dados existentes.

ğŸ§© Estrutura base:
Antes de tudo, o componente tem os seguintes estados:

const [nome, setNome] = useState("");
const [hora, setHora] = useState("");
const [remedios, setRemedios] = useState([]);
const [remedioEmEdicao, setRemedioEmEdicao] = useState(null);

ğŸ” O que cada um faz:
Estado            	FunÃ§Ã£o
nome	              Guarda o texto digitado no input de nome do remÃ©dio
hora	              Guarda o horÃ¡rio escolhido
remedios           	Ã‰ um array com todos os remÃ©dios cadastrados
                   (cada item Ã© um objeto com id, nome e hora)
remedioEmEdicaovvv	Guarda o id do remÃ©dio que estÃ¡ sendo editado. Quando estÃ¡ null, 
                   quer dizer que nÃ£o estamos editando nada.




ğŸ§± 1. Entendendo a funÃ§Ã£o prepararEdicao():
Essa funÃ§Ã£o Ã© chamada quando clicamos no botÃ£o â€œEditarâ€ de algum remÃ©dio:

function prepararEdicao(remedio) {
  setHora(remedio.hora);
  setNome(remedio.nome);
  setRemedioEmEdicao(remedio.id);
}

ğŸ§© Linha por linha:

1. setHora(remedio.hora)
â†’ Pega o valor da propriedade hora do objeto remedio e joga dentro do estado hora.
Isso faz com que o input <input type="time" value={hora} /> seja preenchido automaticamente 
com o horÃ¡rio do remÃ©dio.

2. setNome(remedio.nome)
â†’ Faz a mesma coisa para o nome.
Ou seja, os campos do formulÃ¡rio sÃ£o â€œpreenchidosâ€ automaticamente.

3. setRemedioEmEdicao(remedio.id)
â†’ Define qual remÃ©dio estamos editando, guardando o id dele.
Esse id Ã© Ãºnico e foi criado lÃ¡ na hora que adicionamos o remÃ©dio.
Se estivermos editando o item de id 3, por exemplo, o estado remedioEmEdicao vai virar 3.


ğŸ§  Analogia:
Pense assim:
quando vocÃª clica em â€œEditarâ€, o React pega aquele objeto do array e fala:

â€œOk, Mikael, agora vou colocar o nome e a hora desse item nos campos, e 
guardar o id dele pra saber que esse Ã© o cara que estamos mexendo.â€


ğŸ’¬ Sua dÃºvida sobre event.target.value

â€œChat, eu nÃ£o poderia usar event.target.value aqui?â€

NÃ£o.
O event.target.value sÃ³ existe dentro de eventos de input (quando o usuÃ¡rio digita algo).
No caso de prepararEdicao, vocÃª nÃ£o estÃ¡ pegando valor do input â€” estÃ¡ pegando valor de um objeto existente no array de remÃ©dios.
Ou seja: vocÃª nÃ£o precisa ler o que o usuÃ¡rio digitou, e sim preencher o campo com o que jÃ¡ estava no objeto.



âš™ï¸ 2. FunÃ§Ã£o principal: adicionarRemedio():
Essa Ã© a funÃ§Ã£o que controla tanto o adicionar quanto o editar.

function adicionarRemedio(event) {
  event.preventDefault();

  if (nome.trim() !== '' && hora.trim() !== '') {
    const id = remedioEmEdicao || Date.now();

    const novoMedicamento = { id, nome, hora };

    if (remedioEmEdicao) {
      setRemedios((listaAnterior) =>
        listaAnterior.map((remedio) =>
          remedio.id === remedioEmEdicao ? novoMedicamento : remedio
        )
      );
    } else {
      setRemedios((listaAnterior) => [...listaAnterior, novoMedicamento]);
    }

    setNome('');
    setHora('');
    setRemedioEmEdicao(null);
  }
}


ğŸ§© Entendendo o passo a passo:

1ï¸âƒ£ event.preventDefault()
Evita que o navegador recarregue a pÃ¡gina ao enviar o formulÃ¡rio.


2ï¸âƒ£ const id = remedioEmEdicao || Date.now();
Aqui acontece algo importante:
. Se estivermos editando (remedioEmEdicao tem um valor), ele usa o id existente.
. Se for um novo remÃ©dio, ele cria um id novo com Date.now().

ğŸ§  Isso garante que:
. EdiÃ§Ãµes mantÃªm o mesmo id.
. Novos itens ganham um id novo.


3ï¸âƒ£ Criando o novo objeto:
const novoMedicamento = { id, nome, hora };

Aqui estamos criando um novo objeto que representa o remÃ©dio (seja novo ou atualizado).
Exemplo:

{ id: 17397438493, nome: "Dipirona", hora: "09:00" }



4ï¸âƒ£ Se estamos editandoâ€¦
setRemedios((listaAnterior) =>
  listaAnterior.map((remedio) =>
    remedio.id === remedioEmEdicao ? novoMedicamento : remedio
  )
);


ğŸ§  Explicando passo a passo:

. setRemedios â†’ atualiza o estado remedios.
. (listaAnterior) â†’ Ã© o array atual de remÃ©dios (antes da mudanÃ§a).
Esse parÃ¢metro â€œherdaâ€ o valor do estado automaticamente.
. .map() â†’ percorre cada item do array.
. remedio.id === remedioEmEdicao â†’ verifica se o id atual Ã© o que estamos editando.
. ? novoMedicamento : remedio â†’ se for o mesmo id, substitui; se nÃ£o for, mantÃ©m igual.


ğŸ“˜ Exemplo:
Antes:

[
  { id: 1, nome: "Dipirona", hora: "08:00" },
  { id: 2, nome: "Paracetamol", hora: "10:00" }
]


Depois de editar o de id 1:

[
  { id: 1, nome: "Dipirona", hora: "09:00" },
  { id: 2, nome: "Paracetamol", hora: "10:00" }
]



5ï¸âƒ£ Se for um novo remÃ©dioâ€¦
setRemedios((listaAnterior) => [...listaAnterior, novoMedicamento]);


ğŸ§  Aqui usamos o spread operator (...):
. Ele copia todos os itens do estado anterior (listaAnterior).
. Depois adiciona o novo medicamento no final.

ğŸ“˜ Exemplo:
Antes:

[{ id: 1, nome: "Dipirona", hora: "08:00" }]


Depois:

[
  { id: 1, nome: "Dipirona", hora: "08:00" },
  { id: 2, nome: "Paracetamol", hora: "10:00" }
]

6ï¸âƒ£ Limpando os campos
setNome('');
setHora('');
setRemedioEmEdicao(null);


ğŸ§  Isso acontece depois de salvar (tanto ediÃ§Ã£o quanto adiÃ§Ã£o).

setNome('') e setHora('') limpam os inputs.

setRemedioEmEdicao(null) faz o sistema â€œesquecerâ€ que estÃ¡ editando.
Assim, o botÃ£o volta a mostrar â€œAdicionarâ€ em vez de â€œSalvar alteraÃ§Ãµesâ€.


ğŸ’­ null vs false:

Por que usamos null e nÃ£o false?
. null significa â€œnÃ£o tem valorâ€ (ou â€œnenhum item em ediÃ§Ã£oâ€).
. false Ã© um valor lÃ³gico, usado em condiÃ§Ãµes booleanas (verdadeiro/falso).
Aqui, nÃ£o estamos checando uma condiÃ§Ã£o lÃ³gica, e sim a ausÃªncia de um id â€” por isso null faz mais sentido.


ğŸ§  Entendendo a origem do id:
â€œMas, Chat, de onde vem esse id? Eu nÃ£o vi ele declarado!â€

| O id Ã© criado no momento em que o remÃ©dio Ã© adicionado:

const id = Date.now();

Ele Ã© um nÃºmero baseado na data e hora atual (em milissegundos).
Assim, cada remÃ©dio tem um id Ãºnico â€” e Ã© esse mesmo id que usamos depois para saber qual item editar.



ğŸ¨ 3. JSX resumido:
<form onSubmit={adicionarRemedio}>
  <input
    type="text"
    placeholder="Nome do remÃ©dio"
    value={nome}
    onChange={(e) => setNome(e.target.value)}
  />
  <input
    type="time"
    value={hora}
    onChange={(e) => setHora(e.target.value)}
  />
  <button type="submit">
    {remedioEmEdicao ? "Salvar ediÃ§Ã£o" : "Adicionar"}
  </button>
</form>

{remedios.map((remedio) => (
  <div key={remedio.id}>
    <p>{remedio.nome}</p>
    <p>{remedio.hora}</p>
    <button onClick={() => prepararEdicao(remedio)}>Editar</button>
  </div>
))}




ğŸ“˜ 4. O ciclo completo do editar:
. UsuÃ¡rio adiciona remÃ©dio â†’ entra no array.
. UsuÃ¡rio clica em â€œEditarâ€ â†’ campos sÃ£o preenchidos.
. UsuÃ¡rio muda o nome ou hora â†’ estados nome e hora atualizam.
. UsuÃ¡rio clica em â€œSalvar ediÃ§Ã£oâ€ â†’ item Ã© atualizado no estado.
. Campos limpam â†’ volta pro modo normal.



ğŸ§© 5. Resumo tÃ©cnico e prÃ¡tico:
Conceito	                      O que aprendeu
Inputs controlados	            Ligam diretamente o campo ao estado
Imutabilidade	                  Sempre cria um novo array com map ou [...]
Id Ãºnico	                      Garante que cada item possa ser identificado
Modo de ediÃ§Ã£o	                Controlado via remedioEmEdicao
Null vs False	                  null representa ausÃªncia, false representa valor lÃ³gico
event.target.value	            SÃ³ usado em eventos de input, nÃ£o pra preencher estados diretamente




ğŸ’¡ 6. Exemplo prÃ¡tico com campo extra (observaÃ§Ãµes):

Se vocÃª tivesse um novo campo, como â€œobservaÃ§Ãµesâ€, seria assim:

const [observacao, setObservacao] = useState('');

function prepararEdicao(remedio) {
  setNome(remedio.nome);
  setHora(remedio.hora);
  setObservacao(remedio.observacao || '');
  setRemedioEmEdicao(remedio.id);
}


E ao criar o novo medicamento:

const novoMedicamento = { id, nome, hora, observacao };

Percebe que basta incluir o novo campo no mesmo fluxo â€” a lÃ³gica nÃ£o muda.





ğŸ§© 7. ConclusÃ£o:

Essa feature ensina praticamente tudo o que um dev front-end precisa saber 
sobre React e manipulaÃ§Ã£o de estado:

âœ… Lidar com inputs controlados
âœ… Atualizar listas no estado de forma imutÃ¡vel
âœ… Criar e reaproveitar objetos dinamicamente
âœ… Usar map com operador ternÃ¡rio para atualizar itens especÃ­ficos
âœ… Entender o uso correto de null, false e event.target.value
âœ… E estruturar o cÃ³digo de forma limpa e reaproveitÃ¡vel


























.
ğŸ§© Aula completa â€” Sistema de sugestÃµes automÃ¡ticas de medicamentos
ğŸ¯ Objetivo da feature

Essa feature faz com que, enquanto o usuÃ¡rio digita o nome de um medicamento, o sistema exiba sugestÃµes automÃ¡ticas com base em um array de medicamentos jÃ¡ existentes.
Assim que o usuÃ¡rio clica em uma das sugestÃµes, o campo de nome Ã© preenchido automaticamente e a lista desaparece.

Essa funcionalidade melhora muito a experiÃªncia do usuÃ¡rio e evita erros de digitaÃ§Ã£o, alÃ©m de dar uma aparÃªncia mais inteligente ao sistema.



ğŸ§± Estrutura geral da feature:
Ela Ã© composta basicamente por trÃªs partes principais:

1. Um estado que guarda as sugestÃµes filtradas.
2. Um useEffect que contÃ©m toda a lÃ³gica de verificaÃ§Ã£o e filtragem conforme o usuÃ¡rio digita.
3. Uma renderizaÃ§Ã£o condicional que mostra ou esconde a lista de sugestÃµes conforme as condiÃ§Ãµes.



âš™ï¸ LÃ³gica principal com useEffect:

VersÃ£o final e melhorada do cÃ³digo:

useEffect(() => {
  const nomeSemEspacos = nome.trim(); // ğŸ”¹ remove espaÃ§os extras antes e depois do nome

  // ğŸ§© Caso o campo esteja vazio â†’ limpa as sugestÃµes e encerra a funÃ§Ã£o
  if (!nomeSemEspacos) {
    setSugestoes([]);
    return;
  }

  // ğŸ§  Verifica se o nome digitado jÃ¡ Ã© exatamente igual a algum medicamento existente
  const jaExisteMedicamento = medicamentos.some(
    (medicamento) =>
      medicamento.nome.toLowerCase() === nomeSemEspacos.toLowerCase()
  );

  // ğŸ”¸ Se for igual, nÃ£o precisa sugerir nada â†’ limpa as sugestÃµes
  if (jaExisteMedicamento) {
    setSugestoes([]);
    return;
  }

  // ğŸ” Filtra medicamentos que comecem com o texto digitado
  const sugestoesFiltradas = medicamentos.filter((medicamento) =>
    medicamento.nome.toLowerCase().startsWith(nomeSemEspacos.toLowerCase())
  );

  // ğŸ’¾ Atualiza o estado de sugestÃµes
  setSugestoes(sugestoesFiltradas);
}, [nome, medicamentos]);


ğŸ§  ExplicaÃ§Ã£o detalhada passo a passo:

- ğŸ”¹const nomeSemEspacos = nome.trim():

O mÃ©todo .trim() remove todos os espaÃ§os em branco no inÃ­cio e no fim da string.

ğŸ‘‰ Isso Ã© importante porque o usuÃ¡rio pode digitar "dipirona " (com espaÃ§o no final), 
e sem o .trim() o sistema consideraria "dipirona " diferente de "dipirona".
Assim, trim() evita erros bobos e garante que o filtro funcione corretamente.


- ğŸ”¹if (!nomeSemEspacos) { setSugestoes([]); return; }:

Aqui testamos se o campo de nome estÃ¡ vazio depois de remover os espaÃ§os.
Se estiver vazio, limpamos a lista de sugestÃµes e interrompemos a execuÃ§Ã£o com return.

. !nomeSemEspacos significa â€œse nomeSemEspacos for falsoâ€.
. Uma string vazia ("") Ã© considerada falsy no JavaScript.

ğŸ’¡ Por que fazer isso?
Se o usuÃ¡rio apagar tudo o que digitou, nÃ£o faz sentido mostrar sugestÃµes de medicamentos.



-ğŸ”¹const jaExisteMedicamento = medicamentos.some(...):

O .some() percorre o array de medicamentos e retorna true se pelo menos um item satisfizer a condiÃ§Ã£o.

Aqui, estamos verificando se o nome digitado jÃ¡ Ã© exatamente igual a um medicamento que existe na lista.

const jaExisteMedicamento = medicamentos.some(
  (medicamento) =>
    medicamento.nome.toLowerCase() === nomeSemEspacos.toLowerCase()
);


Usamos toLowerCase() para evitar diferenÃ§a entre letras maiÃºsculas e minÃºsculas.
Por exemplo: â€œDipironaâ€ e â€œdipironaâ€ devem ser tratados como iguais.

ğŸ’¡ Por que isso existe?
Se o nome digitado jÃ¡ for exatamente igual ao de um medicamento, nÃ£o faz sentido continuar exibindo sugestÃµes.
Isso evita que a lista continue aparecendo depois que o usuÃ¡rio jÃ¡ selecionou algo vÃ¡lido.



-ğŸ”¹const sugestoesFiltradas = medicamentos.filter(...):

O mÃ©todo .filter() percorre o array e retorna apenas os itens que passam na condiÃ§Ã£o.

const sugestoesFiltradas = medicamentos.filter((medicamento) =>
  medicamento.nome.toLowerCase().startsWith(nomeSemEspacos.toLowerCase())
);

Usamos startsWith() porque queremos pegar apenas os medicamentos que comeÃ§am com o texto digitado.
Se o usuÃ¡rio digitar â€œdiâ€, aparecerÃ£o â€œDipironaâ€, â€œDiclofenacoâ€, etc.

ğŸ’¡ DiferenÃ§a importante:
Se usÃ¡ssemos .includes() em vez de .startsWith(), ele retornaria qualquer nome 
que contivesse o texto â€” mesmo no meio da palavra.
Mas aqui o comportamento ideal Ã© aparecer somente os nomes que comeÃ§am com o texto digitado.



-ğŸ”¹setSugestoes(sugestoesFiltradas):

Atualiza o estado sugestoes com o resultado do filtro.
Isso dispara uma nova renderizaÃ§Ã£o no React, mostrando as sugestÃµes atualizadas na tela.

ğŸ§  ComparaÃ§Ã£o entre a versÃ£o antiga (com erro) e a versÃ£o atual (corrigida)
ğŸ”¸ Filtro de texto

VersÃ£o antiga: Usava diretamente o valor de nome.
Problema: NÃ£o removia espaÃ§os e comparava incorretamente.
VersÃ£o corrigida: Usa nome.trim().
SoluÃ§Ã£o: Remove espaÃ§os extras antes da comparaÃ§Ã£o.

ğŸ”¸ Condicional

VersÃ£o antiga: NÃ£o tratava o caso em que o nome digitado era idÃªntico a um jÃ¡ existente.
Problema: SugestÃµes continuavam aparecendo mesmo apÃ³s selecionar um nome igual.
VersÃ£o corrigida: Utiliza some() com toLowerCase().
SoluÃ§Ã£o: Garante que, se o nome jÃ¡ existir, as sugestÃµes sejam limpas.

ğŸ”¸ LÃ³gica de atualizaÃ§Ã£o

VersÃ£o antiga: Executava o filtro mesmo quando o campo estava vazio.
Problema: Apareciam sugestÃµes indevidas.
VersÃ£o corrigida: Adiciona if (!nomeSemEspacos) antes do filtro.
SoluÃ§Ã£o: Interrompe a execuÃ§Ã£o quando o campo estÃ¡ vazio.





ğŸ’¬ RenderizaÃ§Ã£o condicional no JSX
{(sugestoes.length > 0 && nome.trim()) && (
  <ul className="border border-gray-300 rounded mt-1 bg-white shadow">
    {sugestoes.map((s, index) => (
      <li
        key={index}
        onClick={() => {
          setNome(s.nome);
          setSugestoes([]);
        }}
        className="p-2 cursor-pointer hover:bg-blue-100"
      >
        {s.nome}
      </li>
    ))}
  </ul>
)}


Vamos entender cada parte:


-ğŸ”¹(sugestoes.length > 0 && nome.trim()) && (...):

Isso Ã© a renderizaÃ§Ã£o condicional com operador lÃ³gico &&.
Ã‰ a forma mais usada em React para exibir algo apenas quando uma condiÃ§Ã£o for verdadeira.

Funciona assim:
. Se sugestoes.length > 0 for true (ou seja, hÃ¡ pelo menos 1 sugestÃ£o)
. E nome.trim() for truthy (ou seja, o campo nÃ£o estÃ¡ vazio)
. EntÃ£o o React renderiza o conteÃºdo dentro dos parÃªnteses (a <ul> com as sugestÃµes).

Se qualquer uma dessas duas condiÃ§Ãµes for falsa â†’ nada Ã© renderizado.


ğŸ’¡ Ã‰ literalmente como escrever:

if (sugestoes.length > 0 && nome.trim()) {
  return <ul>...</ul>
}


-ğŸ”¹.map() â€” criando cada item da lista:
{sugestoes.map((s, index) => (
  <li key={index}> {s.nome} </li>
))}

O mÃ©todo .map() percorre o array sugestoes e cria um elemento JSX para cada item.
. s representa cada sugestÃ£o individual (um objeto do tipo { nome: "Dipirona" }).
. {s.nome} mostra o campo nome de cada sugestÃ£o.
. key={index} Ã© uma chave Ãºnica obrigatÃ³ria no React para listas (ajuda na renderizaÃ§Ã£o eficiente).
ğŸ’¡ Se vocÃª colocasse sÃ³ {s} em vez de {s.nome}, apareceria [object Object], porque s Ã© um objeto inteiro.


-ğŸ”¹onClick={() => { setNome(s.nome); setSugestoes([]); }}:

Esse trecho define o comportamento ao clicar em uma sugestÃ£o.
1. setNome(s.nome) â†’ preenche o campo de texto com o nome da sugestÃ£o clicada.
2. setSugestoes([]) â†’ limpa o array de sugestÃµes, fazendo a lista desaparecer.
ğŸ’¡ Sem essa segunda linha, as sugestÃµes continuariam aparecendo mesmo apÃ³s a seleÃ§Ã£o.

ğŸ§© Resumo dos principais mÃ©todos usados

trim() â†’ Remove espaÃ§os no inÃ­cio e no fim da string.
ğŸ“˜ Exemplo: " dipirona ".trim() â†’ "dipirona"

toLowerCase() â†’ Converte a string para minÃºsculas, garantindo que a comparaÃ§Ã£o nÃ£o falhe por 
causa de letras maiÃºsculas/minÃºsculas.
ğŸ“˜ Exemplo: "Dipirona".toLowerCase() â†’ "dipirona"

some() â†’ Verifica se pelo menos um elemento do array satisfaz a condiÃ§Ã£o passada. Retorna true ou false.
ğŸ“˜ Exemplo: [1, 2, 3].some(n => n > 2) â†’ true

filter() â†’ Retorna todos os elementos do array que atendem Ã  condiÃ§Ã£o.
ğŸ“˜ Exemplo: [1, 2, 3].filter(n => n > 2) â†’ [3]

startsWith() â†’ Verifica se uma string comeÃ§a com os caracteres informados.
ğŸ“˜ Exemplo: "dipirona".startsWith("di") â†’ true

map() â†’ Cria um novo array aplicando uma transformaÃ§Ã£o em cada elemento do array original.
ğŸ“˜ Exemplo: ["a", "b"].map(x => x.toUpperCase()) â†’ ["A", "B"]


ğŸ§­ Resumo mental da lÃ³gica:

1. O usuÃ¡rio digita algo â†’ o estado nome muda.
2. O useEffect Ã© ativado por causa da dependÃªncia [nome].
3. O sistema:
 . remove espaÃ§os (trim);
 . verifica se o campo estÃ¡ vazio (if (!nomeSemEspacos));
 . confere se o nome jÃ¡ existe (some);
 . filtra sugestÃµes que comeÃ§am com o texto (filter + startsWith);
 . atualiza sugestoes.
4. Se houver sugestÃµes â†’ React renderiza a <ul>.
5. UsuÃ¡rio clica em uma â†’ preenche o campo e limpa a lista.

âœ… ConclusÃ£o final
Essa feature ensina vÃ¡rios fundamentos importantes do React e JavaScript moderno:
. Estados e reatividade com useState e useEffect.
. RenderizaÃ§Ã£o condicional com &&.
. ManipulaÃ§Ã£o de arrays e strings (map, filter, some, trim, startsWith).
. Boas prÃ¡ticas de UX, como limpar sugestÃµes e evitar duplicaÃ§Ã£o de nomes.

Com essa base, vocÃª consegue replicar a mesma ideia em qualquer outro contexto â€”
por exemplo, auto-sugestÃµes de cidades, produtos, usuÃ¡rios, categorias, etc.
-->