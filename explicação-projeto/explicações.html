<!--
.

ğŸ“ Aula: Salvando e carregando dados com localStorage no React (versÃ£o final)

1ï¸âƒ£ O que Ã© localStorage?
. Ã‰ um recurso do navegador que guarda dados no prÃ³prio computador do usuÃ¡rio.
. Diferente de um banco de dados, sÃ³ guarda strings (texto).
. Os dados continuam lÃ¡ mesmo se o usuÃ¡rio fechar ou recarregar a pÃ¡gina.

Exemplo simples no console:
localStorage.setItem('nome', 'Mikael'); // salvar
localStorage.getItem('nome');           // "Mikael"


2ï¸âƒ£ Por que usamos JSON.stringify e JSON.parse?
. O localStorage sÃ³ aceita texto.
. Nosso estado remedios Ã© um array de objetos.
. Precisamos converter para string para salvar, e converter de volta para objeto para usar.

JSON.stringify(remedios) // transforma array/objeto em string JSON
JSON.parse(string)       // transforma string JSON de volta em array/objeto



3ï¸âƒ£ A lÃ³gica no React:
const [remedios, setRemedios] = useState(() => {
  const dadosSalvos = localStorage.getItem('remedios');
  return dadosSalvos ? JSON.parse(dadosSalvos) : [];
});

useEffect(() => {
  localStorage.setItem("remedios", JSON.stringify(remedios));
}, [remedios]);



4ï¸âƒ£ Por que usamos useState(() => {...}) com funÃ§Ã£o inicial?
. O React sÃ³ executa essa funÃ§Ã£o na primeira renderizaÃ§Ã£o.
. Com isso, ele lÃª do localStorage uma Ãºnica vez e jÃ¡ inicializa remedios com o que estava salvo.
. Sem essa funÃ§Ã£o, vocÃª precisaria de dois useEffect: um para carregar e outro para salvar.
. Assim, tudo fica mais limpo.



5ï¸âƒ£ O operador ternÃ¡rio (condiÃ§Ã£o ? valor1 : valor2):

Dentro do useState usamos:
return dadosSalvos ? JSON.parse(dadosSalvos) : [];


Isso significa:
. Se dadosSalvos existe â†’ converte e retorna os dados.
. Se nÃ£o existe â†’ retorna um array vazio.


Ã‰ um jeito curto de escrever:
if (dadosSalvos) {
  return JSON.parse(dadosSalvos);
} else {
  return [];
}



6ï¸âƒ£ O que significa o [remedios] no useEffect?
. Ã‰ a lista de dependÃªncias.
. O React sÃ³ roda o useEffect de novo quando algo dessa lista muda.
. Colocando [remedios] â†’ ele roda sempre que remedios mudar.
. Se deixasse [], rodaria sÃ³ uma vez no inÃ­cio.



7ï¸âƒ£ Detalhes do localStorage:
. O localStorage.setItem recebe 2 parÃ¢metros:
. Chave: nome do item (string) â†’ 'remedios'.
. Valor: o que quer salvar (tambÃ©m string).

EntÃ£o:
localStorage.setItem('remedios', JSON.stringify(remedios))

. "remedios" Ã© a chave.
. JSON.stringify(remedios) Ã© o valor salvo (string).


Para ler:
localStorage.getItem('remedios')

. Retorna a string. Se quiser o array de volta, faz:
. JSON.parse(localStorage.getItem('remedios'))



8ï¸âƒ£ Resumo do fluxo
. PÃ¡gina abre â†’ useState lÃª localStorage e preenche remedios.
. UsuÃ¡rio adiciona um remÃ©dio â†’ setRemedios atualiza o estado.
. useEffect detecta mudanÃ§a em remedios â†’ salva os novos dados no localStorage.
. Se recarregar a pÃ¡gina â†’ useState pega os dados salvos e carrega de volta.


9ï¸âƒ£ Vantagens dessa abordagem
. NÃ£o precisa banco de dados para coisas simples.
. Os dados ficam sempre atualizados sem funÃ§Ãµes extras.
. Estado inicial jÃ¡ vem com os dados salvos (sem â€œflashâ€ vazio).
. Evita ter dois useEffect brigando entre si.


ğŸ’¡ Resumo em uma frase:
â€œO localStorage Ã© um armÃ¡rio do navegador.
Usamos useState para pegar o que estÃ¡ dentro quando o app carrega,
e useEffect para guardar tudo de novo sempre que algo mudar.â€
















ğŸ“š Aula: Listagem de Medicamentos no React

1. O objetivo da feature:

O que querÃ­amos com essa branch era:
. âœ… Ler um arquivo JSON (medicamentos.json) com dados de medicamentos (nome, dose, frequÃªncia, horÃ¡rio etc.).
. âœ… Exibir esses dados automaticamente na tela, sem que o usuÃ¡rio precise cadastrar.
. âœ… Deixar esses dados separados da lÃ³gica principal, ou seja, mantÃª-los no JSON em vez de hardcodar dentro do componente.



2. Preparando os estados:
No React usamos estados (useState) para guardar informaÃ§Ãµes que mudam durante a execuÃ§Ã£o da aplicaÃ§Ã£o.

No comeÃ§o do componente criamos dois estados:

const [remedios, setRemedios] = useState([]); 
const [medicamentos, setMedicamentos] = useState([]);

. remedios â†’ armazena os medicamentos que o usuÃ¡rio adiciona manualmente no formulÃ¡rio.
. medicamentos â†’ armazena os medicamentos que vÃªm do arquivo JSON.

Assim conseguimos trabalhar separadamente com cada fonte de dados.



3. Buscando o JSON com useEffect

Para carregar os dados assim que a pÃ¡gina abre, usamos o hook useEffect.

useEffect(() => {
  fetch("/medicamentos.json")
    .then((res) => res.json())
    .then((data) => setMedicamentos(data))
    .catch((error) =>
      console.log("Erro ao carregar medicamentos", error)
    );
}, []);

ExplicaÃ§Ã£o:
. fetch("/medicamentos.json") â†’ faz a requisiÃ§Ã£o para o arquivo JSON.
. .then(res => res.json()) â†’ transforma a resposta em um objeto JavaScript.
. .then(data => setMedicamentos(data)) â†’ guarda esses dados no estado medicamentos.
. catch(...) â†’ captura possÃ­veis erros.
. O [] no final garante que isso sÃ³ rode uma vez, quando o componente for montado.



4. Renderizando os medicamentos:

Depois que o JSON foi carregado no estado medicamentos, basta percorrer esse array com .map() e renderizar na tela.

<div className="mt-10">
  <ul>
    {medicamentos.map((medicamento) => (
      <li key={medicamento.id}>
        <strong>
          {medicamento.nome} - {medicamento.dose}
        </strong>{" "}
        <br />
        horÃ¡rio: {medicamento.horario} - frequÃªncia:{" "}
        {medicamento.frequencia}
      </li>
    ))}
  </ul>
</div>


O que acontece aqui:
. medicamentos.map(...) â†’ percorre cada item do array.
. key={medicamento.id} â†’ cada item precisa de uma chave Ãºnica.
. Dentro do JSX mostramos nome, dose, horÃ¡rio e frequÃªncia.
. Ou seja, sempre que o arquivo JSON mudar, a interface automaticamente vai refletir esses dados.



5. IntegraÃ§Ã£o com a lÃ³gica jÃ¡ existente:
Antes, nosso app sÃ³ cadastrava manualmente com o formulÃ¡rio (remedios).
Agora temos duas listas:

. Lista de remÃ©dios cadastrados pelo usuÃ¡rio
. Lista de medicamentos vindos do JSON

Assim a aplicaÃ§Ã£o mostra tanto o que o usuÃ¡rio digitou quanto o que jÃ¡ estava registrado no â€œbancoâ€ de medicamentos.



6. Por que isso Ã© importante?
. ğŸ“‚ SeparaÃ§Ã£o de responsabilidades â†’ os dados ficam em um arquivo externo (JSON).
. âš¡ ReutilizaÃ§Ã£o â†’ podemos mudar o JSON sem alterar o cÃ³digo.
. ğŸ”„ Dinamicidade â†’ se o JSON for atualizado, a interface tambÃ©m Ã©.
. ğŸ’» PrÃ³xima evoluÃ§Ã£o â†’ no futuro, esse fetch pode vir de uma API real, sem mudar muita coisa no cÃ³digo.


ğŸš€ ConclusÃ£o

Na branch listagem-medicamento, aprendemos:
1. Como usar useState para armazenar dados vindos de diferentes fontes.
2. Como usar useEffect + fetch para buscar dados de um JSON.
3. Como percorrer arrays com .map() para renderizar listas no React.
4. Como separar a lÃ³gica de medicamentos cadastrados manualmente e carregados automaticamente.

Isso fecha a funcionalidade de listar medicamentos.

Na prÃ¡tica, vocÃª agora tem:
. Um mini banco de dados local (JSON).
. IntegraÃ§Ã£o desse â€œbancoâ€ com React.
. ExibiÃ§Ã£o dinÃ¢mica dos dados.
























ğŸ”¹ 1. git checkout develop

Esse comando faz vocÃª entrar na branch develop.

Se jÃ¡ estiver nela, o Git responde algo como Already on 'develop'.

ğŸ”¹ 2. git merge main

Aqui Ã© onde sempre rola confusÃ£o ğŸ‘€

Esse comando pega o histÃ³rico da main e junta dentro da develop.

Ou seja: vocÃª estÃ¡ atualizando a develop com tudo que jÃ¡ existe na main.

NÃ£o Ã© o contrÃ¡rio. A main nÃ£o recebe nada aqui.

ğŸ“Œ EntÃ£o:

Branch ativa (onde vocÃª estÃ¡) = quem vai ser atualizada.

Branch do merge (que vocÃª passa como argumento) = quem traz as mudanÃ§as.

ğŸ‘‰ Como vocÃª estava em develop, o merge significa:

"junte as mudanÃ§as da main dentro da develop".

ğŸ”¹ 3. O que Ã© merge

Exatamente: merge = juntar o histÃ³rico de duas branches.
Ele cria um commit especial (merge commit) se houver diferenÃ§as entre elas.
Se nÃ£o houver conflitos, o Git une automaticamente.

ğŸ“Œ Se houver conflitos, vocÃª precisa resolver manualmente (como aconteceu antes).

ğŸ”¹ 4. git push origin develop

O push envia a sua branch local (develop) pro repositÃ³rio remoto (GitHub, GitLab etc.).

origin = apelido padrÃ£o pro repositÃ³rio remoto.

develop = branch que vocÃª estÃ¡ enviando.

ğŸ’¡ Se vocÃª sÃ³ fizesse o merge localmente e nÃ£o desse o push, a develop remota ficaria desatualizada.
O push origin develop garante que a branch remota fique igual Ã  sua local.




âœ… Resumindo sua explicaÃ§Ã£o corrigida:
. checkout develop â†’ entro na branch develop.
. merge main â†’ atualizo develop com tudo que estÃ¡ na main.
. push origin develop â†’ envio a develop atualizada pro GitHub.


















ğŸ§  Aula: Criando a funcionalidade Remover RemÃ©dio
ğŸ¯ Objetivo:

Permitir que o usuÃ¡rio remova um remÃ©dio da lista exibida na tela, de forma dinÃ¢mica, sem precisar recarregar a pÃ¡gina.

ğŸ§© Etapas de implementaÃ§Ã£o
1ï¸âƒ£ Entendimento do problema

QuerÃ­amos que cada remÃ©dio adicionado tivesse um botÃ£o de remover.
Quando o usuÃ¡rio clicasse, aquele remÃ©dio deveria sumir da lista imediatamente.

Pra isso, precisarÃ­amos:
. Acessar o estado atual da lista de remÃ©dios (remedios);
. Remover apenas o item selecionado, sem alterar o resto;
. Atualizar o estado pra refletir essa mudanÃ§a na interface 
(React faz isso automaticamente quando o estado muda).



2ï¸âƒ£ Criando a funÃ§Ã£o de remover

Usamos o React Hook useState que controla a lista de remÃ©dios:

const [remedios, setRemedios] = useState([]);


Depois criamos a funÃ§Ã£o removerRemedio:

function removerRemedio(idDoRemedio) {
  setRemedios((listaAnteriorDeRemedios) => 
    listaAnteriorDeRemedios.filter((remedio) => remedio.id !== idDoRemedio)
  );
}

ğŸ§© Explicando linha por linha:
. setRemedios(...) â†’ Ã© a funÃ§Ã£o que atualiza o estado remedios.
. (listaAnteriorDeRemedios) â†’ Ã© o estado antigo (a lista antes da remoÃ§Ã£o).
Esse nome Ã© sÃ³ pra clareza. Em alguns cÃ³digos aparece como prev, que Ã© 
abreviaÃ§Ã£o de previous, ou seja, â€œanteriorâ€.
. .filter() â†’ cria uma nova lista, sem modificar a original, mantendo apenas 
os elementos que passam no teste.
. (remedio) => remedio.id !== idDoRemedio â†’ esse Ã© o teste: sÃ³ ficam na lista os 
remÃ©dios cujo id nÃ£o Ã© igual ao id que queremos remover.
. O React entÃ£o re-renderiza o componente mostrando a nova lista, jÃ¡ sem o remÃ©dio removido.



3ï¸âƒ£ Ligando o botÃ£o Ã  funÃ§Ã£o:

Dentro do map() que mostra os remÃ©dios na tela, adicionamos um botÃ£o:

<button
  onClick={() => removerRemedio(remedio.id)}
  className="mt-2 bg-red-500 text-white px-3 py-1 rounded hover:bg-red-600"
>
  Remover
</button>

ğŸ§© O que acontece aqui:
. O onClick chama a funÃ§Ã£o removerRemedio, passando o id do remÃ©dio.
. Assim que o botÃ£o Ã© clicado, a funÃ§Ã£o roda e o item some da tela.



4ï¸âƒ£ Testando a funcionalidade:

Passos testados:
1. Adicionar 2 ou mais remÃ©dios.
2. Clicar em â€œRemoverâ€ em um deles.
3. Verificar se apenas aquele sumiu da lista.
4. Conferir se o resto da lista continua igual. âœ…

ğŸ§¹ Resultado final (resumo visual)
function removerRemedio(idDoRemedio) {
  setRemedios((listaAnterior) =>
    listaAnterior.filter((remedio) => remedio.id !== idDoRemedio)
  );
}



ğŸ’¡ Resumo conceitual:
.filter() percorre a lista e cria uma nova, com todos os itens que 
nÃ£o tÃªm o ID igual ao que queremos remover.
Depois setRemedios atualiza o estado com essa nova lista.
O React automaticamente refaz a renderizaÃ§Ã£o â€” e o item desaparece da tela.


ğŸ“š ConclusÃ£o
. Usamos o conceito de imutabilidade do React: nunca alteramos o 
estado direto, sempre criamos uma nova lista.
. Entendemos o uso do callback no setState, pra trabalhar com o 
valor anterior de forma segura.
. Aplicamos o .filter(), uma funÃ§Ã£o nativa do JavaScript muito 
usada pra manipular arrays no React.



























ğŸ§  Aula Completa â€“ Funcionalidade â€œEditar RemÃ©dioâ€ no React

ğŸ“˜ Objetivo:
Permitir que o usuÃ¡rio adicione, edite e atualize remÃ©dios sem criar duplicaÃ§Ãµes, 
mantendo o estado da lista atualizado em tempo real.
Essa funcionalidade representa o â€œUâ€ do CRUD (Update) â€” atualizar dados existentes.

ğŸ§© Estrutura base:
Antes de tudo, o componente tem os seguintes estados:

const [nome, setNome] = useState("");
const [hora, setHora] = useState("");
const [remedios, setRemedios] = useState([]);
const [remedioEmEdicao, setRemedioEmEdicao] = useState(null);

ğŸ” O que cada um faz:
Estado            	FunÃ§Ã£o
nome	              Guarda o texto digitado no input de nome do remÃ©dio
hora	              Guarda o horÃ¡rio escolhido
remedios           	Ã‰ um array com todos os remÃ©dios cadastrados
                   (cada item Ã© um objeto com id, nome e hora)
remedioEmEdicaovvv	Guarda o id do remÃ©dio que estÃ¡ sendo editado. Quando estÃ¡ null, 
                   quer dizer que nÃ£o estamos editando nada.




ğŸ§± 1. Entendendo a funÃ§Ã£o prepararEdicao():
Essa funÃ§Ã£o Ã© chamada quando clicamos no botÃ£o â€œEditarâ€ de algum remÃ©dio:

function prepararEdicao(remedio) {
  setHora(remedio.hora);
  setNome(remedio.nome);
  setRemedioEmEdicao(remedio.id);
}

ğŸ§© Linha por linha:

1. setHora(remedio.hora)
â†’ Pega o valor da propriedade hora do objeto remedio e joga dentro do estado hora.
Isso faz com que o input <input type="time" value={hora} /> seja preenchido automaticamente 
com o horÃ¡rio do remÃ©dio.

2. setNome(remedio.nome)
â†’ Faz a mesma coisa para o nome.
Ou seja, os campos do formulÃ¡rio sÃ£o â€œpreenchidosâ€ automaticamente.

3. setRemedioEmEdicao(remedio.id)
â†’ Define qual remÃ©dio estamos editando, guardando o id dele.
Esse id Ã© Ãºnico e foi criado lÃ¡ na hora que adicionamos o remÃ©dio.
Se estivermos editando o item de id 3, por exemplo, o estado remedioEmEdicao vai virar 3.


ğŸ§  Analogia:
Pense assim:
quando vocÃª clica em â€œEditarâ€, o React pega aquele objeto do array e fala:

â€œOk, Mikael, agora vou colocar o nome e a hora desse item nos campos, e 
guardar o id dele pra saber que esse Ã© o cara que estamos mexendo.â€


ğŸ’¬ Sua dÃºvida sobre event.target.value

â€œChat, eu nÃ£o poderia usar event.target.value aqui?â€

NÃ£o.
O event.target.value sÃ³ existe dentro de eventos de input (quando o usuÃ¡rio digita algo).
No caso de prepararEdicao, vocÃª nÃ£o estÃ¡ pegando valor do input â€” estÃ¡ pegando valor de um objeto existente no array de remÃ©dios.
Ou seja: vocÃª nÃ£o precisa ler o que o usuÃ¡rio digitou, e sim preencher o campo com o que jÃ¡ estava no objeto.



âš™ï¸ 2. FunÃ§Ã£o principal: adicionarRemedio():
Essa Ã© a funÃ§Ã£o que controla tanto o adicionar quanto o editar.

function adicionarRemedio(event) {
  event.preventDefault();

  if (nome.trim() !== '' && hora.trim() !== '') {
    const id = remedioEmEdicao || Date.now();

    const novoMedicamento = { id, nome, hora };

    if (remedioEmEdicao) {
      setRemedios((listaAnterior) =>
        listaAnterior.map((remedio) =>
          remedio.id === remedioEmEdicao ? novoMedicamento : remedio
        )
      );
    } else {
      setRemedios((listaAnterior) => [...listaAnterior, novoMedicamento]);
    }

    setNome('');
    setHora('');
    setRemedioEmEdicao(null);
  }
}


ğŸ§© Entendendo o passo a passo:

1ï¸âƒ£ event.preventDefault()
Evita que o navegador recarregue a pÃ¡gina ao enviar o formulÃ¡rio.


2ï¸âƒ£ const id = remedioEmEdicao || Date.now();
Aqui acontece algo importante:
. Se estivermos editando (remedioEmEdicao tem um valor), ele usa o id existente.
. Se for um novo remÃ©dio, ele cria um id novo com Date.now().

ğŸ§  Isso garante que:
. EdiÃ§Ãµes mantÃªm o mesmo id.
. Novos itens ganham um id novo.


3ï¸âƒ£ Criando o novo objeto:
const novoMedicamento = { id, nome, hora };

Aqui estamos criando um novo objeto que representa o remÃ©dio (seja novo ou atualizado).
Exemplo:

{ id: 17397438493, nome: "Dipirona", hora: "09:00" }



4ï¸âƒ£ Se estamos editandoâ€¦
setRemedios((listaAnterior) =>
  listaAnterior.map((remedio) =>
    remedio.id === remedioEmEdicao ? novoMedicamento : remedio
  )
);


ğŸ§  Explicando passo a passo:

. setRemedios â†’ atualiza o estado remedios.
. (listaAnterior) â†’ Ã© o array atual de remÃ©dios (antes da mudanÃ§a).
Esse parÃ¢metro â€œherdaâ€ o valor do estado automaticamente.
. .map() â†’ percorre cada item do array.
. remedio.id === remedioEmEdicao â†’ verifica se o id atual Ã© o que estamos editando.
. ? novoMedicamento : remedio â†’ se for o mesmo id, substitui; se nÃ£o for, mantÃ©m igual.


ğŸ“˜ Exemplo:
Antes:

[
  { id: 1, nome: "Dipirona", hora: "08:00" },
  { id: 2, nome: "Paracetamol", hora: "10:00" }
]


Depois de editar o de id 1:

[
  { id: 1, nome: "Dipirona", hora: "09:00" },
  { id: 2, nome: "Paracetamol", hora: "10:00" }
]



5ï¸âƒ£ Se for um novo remÃ©dioâ€¦
setRemedios((listaAnterior) => [...listaAnterior, novoMedicamento]);


ğŸ§  Aqui usamos o spread operator (...):
. Ele copia todos os itens do estado anterior (listaAnterior).
. Depois adiciona o novo medicamento no final.

ğŸ“˜ Exemplo:
Antes:

[{ id: 1, nome: "Dipirona", hora: "08:00" }]


Depois:

[
  { id: 1, nome: "Dipirona", hora: "08:00" },
  { id: 2, nome: "Paracetamol", hora: "10:00" }
]

6ï¸âƒ£ Limpando os campos
setNome('');
setHora('');
setRemedioEmEdicao(null);


ğŸ§  Isso acontece depois de salvar (tanto ediÃ§Ã£o quanto adiÃ§Ã£o).

setNome('') e setHora('') limpam os inputs.

setRemedioEmEdicao(null) faz o sistema â€œesquecerâ€ que estÃ¡ editando.
Assim, o botÃ£o volta a mostrar â€œAdicionarâ€ em vez de â€œSalvar alteraÃ§Ãµesâ€.


ğŸ’­ null vs false:

Por que usamos null e nÃ£o false?
. null significa â€œnÃ£o tem valorâ€ (ou â€œnenhum item em ediÃ§Ã£oâ€).
. false Ã© um valor lÃ³gico, usado em condiÃ§Ãµes booleanas (verdadeiro/falso).
Aqui, nÃ£o estamos checando uma condiÃ§Ã£o lÃ³gica, e sim a ausÃªncia de um id â€” por isso null faz mais sentido.


ğŸ§  Entendendo a origem do id:
â€œMas, Chat, de onde vem esse id? Eu nÃ£o vi ele declarado!â€

| O id Ã© criado no momento em que o remÃ©dio Ã© adicionado:

const id = Date.now();

Ele Ã© um nÃºmero baseado na data e hora atual (em milissegundos).
Assim, cada remÃ©dio tem um id Ãºnico â€” e Ã© esse mesmo id que usamos depois para saber qual item editar.



ğŸ¨ 3. JSX resumido:
<form onSubmit={adicionarRemedio}>
  <input
    type="text"
    placeholder="Nome do remÃ©dio"
    value={nome}
    onChange={(e) => setNome(e.target.value)}
  />
  <input
    type="time"
    value={hora}
    onChange={(e) => setHora(e.target.value)}
  />
  <button type="submit">
    {remedioEmEdicao ? "Salvar ediÃ§Ã£o" : "Adicionar"}
  </button>
</form>

{remedios.map((remedio) => (
  <div key={remedio.id}>
    <p>{remedio.nome}</p>
    <p>{remedio.hora}</p>
    <button onClick={() => prepararEdicao(remedio)}>Editar</button>
  </div>
))}




ğŸ“˜ 4. O ciclo completo do editar:
. UsuÃ¡rio adiciona remÃ©dio â†’ entra no array.
. UsuÃ¡rio clica em â€œEditarâ€ â†’ campos sÃ£o preenchidos.
. UsuÃ¡rio muda o nome ou hora â†’ estados nome e hora atualizam.
. UsuÃ¡rio clica em â€œSalvar ediÃ§Ã£oâ€ â†’ item Ã© atualizado no estado.
. Campos limpam â†’ volta pro modo normal.



ğŸ§© 5. Resumo tÃ©cnico e prÃ¡tico:
Conceito	                      O que aprendeu
Inputs controlados	            Ligam diretamente o campo ao estado
Imutabilidade	                  Sempre cria um novo array com map ou [...]
Id Ãºnico	                      Garante que cada item possa ser identificado
Modo de ediÃ§Ã£o	                Controlado via remedioEmEdicao
Null vs False	                  null representa ausÃªncia, false representa valor lÃ³gico
event.target.value	            SÃ³ usado em eventos de input, nÃ£o pra preencher estados diretamente




ğŸ’¡ 6. Exemplo prÃ¡tico com campo extra (observaÃ§Ãµes):

Se vocÃª tivesse um novo campo, como â€œobservaÃ§Ãµesâ€, seria assim:

const [observacao, setObservacao] = useState('');

function prepararEdicao(remedio) {
  setNome(remedio.nome);
  setHora(remedio.hora);
  setObservacao(remedio.observacao || '');
  setRemedioEmEdicao(remedio.id);
}


E ao criar o novo medicamento:

const novoMedicamento = { id, nome, hora, observacao };

Percebe que basta incluir o novo campo no mesmo fluxo â€” a lÃ³gica nÃ£o muda.





ğŸ§© 7. ConclusÃ£o:

Essa feature ensina praticamente tudo o que um dev front-end precisa saber 
sobre React e manipulaÃ§Ã£o de estado:

âœ… Lidar com inputs controlados
âœ… Atualizar listas no estado de forma imutÃ¡vel
âœ… Criar e reaproveitar objetos dinamicamente
âœ… Usar map com operador ternÃ¡rio para atualizar itens especÃ­ficos
âœ… Entender o uso correto de null, false e event.target.value
âœ… E estruturar o cÃ³digo de forma limpa e reaproveitÃ¡vel
-->