<!--
.

📝 Aula: Salvando e carregando dados com localStorage no React (versão final)

1️⃣ O que é localStorage?
. É um recurso do navegador que guarda dados no próprio computador do usuário.
. Diferente de um banco de dados, só guarda strings (texto).
. Os dados continuam lá mesmo se o usuário fechar ou recarregar a página.

Exemplo simples no console:
localStorage.setItem('nome', 'Mikael'); // salvar
localStorage.getItem('nome');           // "Mikael"


2️⃣ Por que usamos JSON.stringify e JSON.parse?
. O localStorage só aceita texto.
. Nosso estado remedios é um array de objetos.
. Precisamos converter para string para salvar, e converter de volta para objeto para usar.

JSON.stringify(remedios) // transforma array/objeto em string JSON
JSON.parse(string)       // transforma string JSON de volta em array/objeto



3️⃣ A lógica no React:
const [remedios, setRemedios] = useState(() => {
  const dadosSalvos = localStorage.getItem('remedios');
  return dadosSalvos ? JSON.parse(dadosSalvos) : [];
});

useEffect(() => {
  localStorage.setItem("remedios", JSON.stringify(remedios));
}, [remedios]);



4️⃣ Por que usamos useState(() => {...}) com função inicial?
. O React só executa essa função na primeira renderização.
. Com isso, ele lê do localStorage uma única vez e já inicializa remedios com o que estava salvo.
. Sem essa função, você precisaria de dois useEffect: um para carregar e outro para salvar.
. Assim, tudo fica mais limpo.



5️⃣ O operador ternário (condição ? valor1 : valor2):

Dentro do useState usamos:
return dadosSalvos ? JSON.parse(dadosSalvos) : [];


Isso significa:
. Se dadosSalvos existe → converte e retorna os dados.
. Se não existe → retorna um array vazio.


É um jeito curto de escrever:
if (dadosSalvos) {
  return JSON.parse(dadosSalvos);
} else {
  return [];
}



6️⃣ O que significa o [remedios] no useEffect?
. É a lista de dependências.
. O React só roda o useEffect de novo quando algo dessa lista muda.
. Colocando [remedios] → ele roda sempre que remedios mudar.
. Se deixasse [], rodaria só uma vez no início.



7️⃣ Detalhes do localStorage:
. O localStorage.setItem recebe 2 parâmetros:
. Chave: nome do item (string) → 'remedios'.
. Valor: o que quer salvar (também string).

Então:
localStorage.setItem('remedios', JSON.stringify(remedios))

. "remedios" é a chave.
. JSON.stringify(remedios) é o valor salvo (string).


Para ler:
localStorage.getItem('remedios')

. Retorna a string. Se quiser o array de volta, faz:
. JSON.parse(localStorage.getItem('remedios'))



8️⃣ Resumo do fluxo
. Página abre → useState lê localStorage e preenche remedios.
. Usuário adiciona um remédio → setRemedios atualiza o estado.
. useEffect detecta mudança em remedios → salva os novos dados no localStorage.
. Se recarregar a página → useState pega os dados salvos e carrega de volta.


9️⃣ Vantagens dessa abordagem
. Não precisa banco de dados para coisas simples.
. Os dados ficam sempre atualizados sem funções extras.
. Estado inicial já vem com os dados salvos (sem “flash” vazio).
. Evita ter dois useEffect brigando entre si.


💡 Resumo em uma frase:
“O localStorage é um armário do navegador.
Usamos useState para pegar o que está dentro quando o app carrega,
e useEffect para guardar tudo de novo sempre que algo mudar.”
















📚 Aula: Listagem de Medicamentos no React

1. O objetivo da feature:

O que queríamos com essa branch era:
. ✅ Ler um arquivo JSON (medicamentos.json) com dados de medicamentos (nome, dose, frequência, horário etc.).
. ✅ Exibir esses dados automaticamente na tela, sem que o usuário precise cadastrar.
. ✅ Deixar esses dados separados da lógica principal, ou seja, mantê-los no JSON em vez de hardcodar dentro do componente.



2. Preparando os estados:
No React usamos estados (useState) para guardar informações que mudam durante a execução da aplicação.

No começo do componente criamos dois estados:

const [remedios, setRemedios] = useState([]); 
const [medicamentos, setMedicamentos] = useState([]);

. remedios → armazena os medicamentos que o usuário adiciona manualmente no formulário.
. medicamentos → armazena os medicamentos que vêm do arquivo JSON.

Assim conseguimos trabalhar separadamente com cada fonte de dados.



3. Buscando o JSON com useEffect

Para carregar os dados assim que a página abre, usamos o hook useEffect.

useEffect(() => {
  fetch("/medicamentos.json")
    .then((res) => res.json())
    .then((data) => setMedicamentos(data))
    .catch((error) =>
      console.log("Erro ao carregar medicamentos", error)
    );
}, []);

Explicação:
. fetch("/medicamentos.json") → faz a requisição para o arquivo JSON.
. .then(res => res.json()) → transforma a resposta em um objeto JavaScript.
. .then(data => setMedicamentos(data)) → guarda esses dados no estado medicamentos.
. catch(...) → captura possíveis erros.
. O [] no final garante que isso só rode uma vez, quando o componente for montado.



4. Renderizando os medicamentos:

Depois que o JSON foi carregado no estado medicamentos, basta percorrer esse array com .map() e renderizar na tela.

<div className="mt-10">
  <ul>
    {medicamentos.map((medicamento) => (
      <li key={medicamento.id}>
        <strong>
          {medicamento.nome} - {medicamento.dose}
        </strong>{" "}
        <br />
        horário: {medicamento.horario} - frequência:{" "}
        {medicamento.frequencia}
      </li>
    ))}
  </ul>
</div>


O que acontece aqui:
. medicamentos.map(...) → percorre cada item do array.
. key={medicamento.id} → cada item precisa de uma chave única.
. Dentro do JSX mostramos nome, dose, horário e frequência.
. Ou seja, sempre que o arquivo JSON mudar, a interface automaticamente vai refletir esses dados.



5. Integração com a lógica já existente:
Antes, nosso app só cadastrava manualmente com o formulário (remedios).
Agora temos duas listas:

. Lista de remédios cadastrados pelo usuário
. Lista de medicamentos vindos do JSON

Assim a aplicação mostra tanto o que o usuário digitou quanto o que já estava registrado no “banco” de medicamentos.



6. Por que isso é importante?
. 📂 Separação de responsabilidades → os dados ficam em um arquivo externo (JSON).
. ⚡ Reutilização → podemos mudar o JSON sem alterar o código.
. 🔄 Dinamicidade → se o JSON for atualizado, a interface também é.
. 💻 Próxima evolução → no futuro, esse fetch pode vir de uma API real, sem mudar muita coisa no código.


🚀 Conclusão

Na branch listagem-medicamento, aprendemos:
1. Como usar useState para armazenar dados vindos de diferentes fontes.
2. Como usar useEffect + fetch para buscar dados de um JSON.
3. Como percorrer arrays com .map() para renderizar listas no React.
4. Como separar a lógica de medicamentos cadastrados manualmente e carregados automaticamente.

Isso fecha a funcionalidade de listar medicamentos.

Na prática, você agora tem:
. Um mini banco de dados local (JSON).
. Integração desse “banco” com React.
. Exibição dinâmica dos dados.
























🔹 1. git checkout develop

Esse comando faz você entrar na branch develop.

Se já estiver nela, o Git responde algo como Already on 'develop'.

🔹 2. git merge main

Aqui é onde sempre rola confusão 👀

Esse comando pega o histórico da main e junta dentro da develop.

Ou seja: você está atualizando a develop com tudo que já existe na main.

Não é o contrário. A main não recebe nada aqui.

📌 Então:

Branch ativa (onde você está) = quem vai ser atualizada.

Branch do merge (que você passa como argumento) = quem traz as mudanças.

👉 Como você estava em develop, o merge significa:

"junte as mudanças da main dentro da develop".

🔹 3. O que é merge

Exatamente: merge = juntar o histórico de duas branches.
Ele cria um commit especial (merge commit) se houver diferenças entre elas.
Se não houver conflitos, o Git une automaticamente.

📌 Se houver conflitos, você precisa resolver manualmente (como aconteceu antes).

🔹 4. git push origin develop

O push envia a sua branch local (develop) pro repositório remoto (GitHub, GitLab etc.).

origin = apelido padrão pro repositório remoto.

develop = branch que você está enviando.

💡 Se você só fizesse o merge localmente e não desse o push, a develop remota ficaria desatualizada.
O push origin develop garante que a branch remota fique igual à sua local.




✅ Resumindo sua explicação corrigida:
. checkout develop → entro na branch develop.
. merge main → atualizo develop com tudo que está na main.
. push origin develop → envio a develop atualizada pro GitHub.


















🧠 Aula: Criando a funcionalidade Remover Remédio
🎯 Objetivo:

Permitir que o usuário remova um remédio da lista exibida na tela, de forma dinâmica, sem precisar recarregar a página.

🧩 Etapas de implementação
1️⃣ Entendimento do problema

Queríamos que cada remédio adicionado tivesse um botão de remover.
Quando o usuário clicasse, aquele remédio deveria sumir da lista imediatamente.

Pra isso, precisaríamos:
. Acessar o estado atual da lista de remédios (remedios);
. Remover apenas o item selecionado, sem alterar o resto;
. Atualizar o estado pra refletir essa mudança na interface 
(React faz isso automaticamente quando o estado muda).



2️⃣ Criando a função de remover

Usamos o React Hook useState que controla a lista de remédios:

const [remedios, setRemedios] = useState([]);


Depois criamos a função removerRemedio:

function removerRemedio(idDoRemedio) {
  setRemedios((listaAnteriorDeRemedios) => 
    listaAnteriorDeRemedios.filter((remedio) => remedio.id !== idDoRemedio)
  );
}

🧩 Explicando linha por linha:
. setRemedios(...) → é a função que atualiza o estado remedios.
. (listaAnteriorDeRemedios) → é o estado antigo (a lista antes da remoção).
Esse nome é só pra clareza. Em alguns códigos aparece como prev, que é 
abreviação de previous, ou seja, “anterior”.
. .filter() → cria uma nova lista, sem modificar a original, mantendo apenas 
os elementos que passam no teste.
. (remedio) => remedio.id !== idDoRemedio → esse é o teste: só ficam na lista os 
remédios cujo id não é igual ao id que queremos remover.
. O React então re-renderiza o componente mostrando a nova lista, já sem o remédio removido.



3️⃣ Ligando o botão à função:

Dentro do map() que mostra os remédios na tela, adicionamos um botão:

<button
  onClick={() => removerRemedio(remedio.id)}
  className="mt-2 bg-red-500 text-white px-3 py-1 rounded hover:bg-red-600"
>
  Remover
</button>

🧩 O que acontece aqui:
. O onClick chama a função removerRemedio, passando o id do remédio.
. Assim que o botão é clicado, a função roda e o item some da tela.



4️⃣ Testando a funcionalidade:

Passos testados:
1. Adicionar 2 ou mais remédios.
2. Clicar em “Remover” em um deles.
3. Verificar se apenas aquele sumiu da lista.
4. Conferir se o resto da lista continua igual. ✅

🧹 Resultado final (resumo visual)
function removerRemedio(idDoRemedio) {
  setRemedios((listaAnterior) =>
    listaAnterior.filter((remedio) => remedio.id !== idDoRemedio)
  );
}



💡 Resumo conceitual:
.filter() percorre a lista e cria uma nova, com todos os itens que 
não têm o ID igual ao que queremos remover.
Depois setRemedios atualiza o estado com essa nova lista.
O React automaticamente refaz a renderização — e o item desaparece da tela.


📚 Conclusão
. Usamos o conceito de imutabilidade do React: nunca alteramos o 
estado direto, sempre criamos uma nova lista.
. Entendemos o uso do callback no setState, pra trabalhar com o 
valor anterior de forma segura.
. Aplicamos o .filter(), uma função nativa do JavaScript muito 
usada pra manipular arrays no React.



























🧠 Aula Completa – Funcionalidade “Editar Remédio” no React

📘 Objetivo:
Permitir que o usuário adicione, edite e atualize remédios sem criar duplicações, 
mantendo o estado da lista atualizado em tempo real.
Essa funcionalidade representa o “U” do CRUD (Update) — atualizar dados existentes.

🧩 Estrutura base:
Antes de tudo, o componente tem os seguintes estados:

const [nome, setNome] = useState("");
const [hora, setHora] = useState("");
const [remedios, setRemedios] = useState([]);
const [remedioEmEdicao, setRemedioEmEdicao] = useState(null);

🔍 O que cada um faz:
Estado            	Função
nome	              Guarda o texto digitado no input de nome do remédio
hora	              Guarda o horário escolhido
remedios           	É um array com todos os remédios cadastrados
                   (cada item é um objeto com id, nome e hora)
remedioEmEdicaovvv	Guarda o id do remédio que está sendo editado. Quando está null, 
                   quer dizer que não estamos editando nada.




🧱 1. Entendendo a função prepararEdicao():
Essa função é chamada quando clicamos no botão “Editar” de algum remédio:

function prepararEdicao(remedio) {
  setHora(remedio.hora);
  setNome(remedio.nome);
  setRemedioEmEdicao(remedio.id);
}

🧩 Linha por linha:

1. setHora(remedio.hora)
→ Pega o valor da propriedade hora do objeto remedio e joga dentro do estado hora.
Isso faz com que o input <input type="time" value={hora} /> seja preenchido automaticamente 
com o horário do remédio.

2. setNome(remedio.nome)
→ Faz a mesma coisa para o nome.
Ou seja, os campos do formulário são “preenchidos” automaticamente.

3. setRemedioEmEdicao(remedio.id)
→ Define qual remédio estamos editando, guardando o id dele.
Esse id é único e foi criado lá na hora que adicionamos o remédio.
Se estivermos editando o item de id 3, por exemplo, o estado remedioEmEdicao vai virar 3.


🧠 Analogia:
Pense assim:
quando você clica em “Editar”, o React pega aquele objeto do array e fala:

“Ok, Mikael, agora vou colocar o nome e a hora desse item nos campos, e 
guardar o id dele pra saber que esse é o cara que estamos mexendo.”


💬 Sua dúvida sobre event.target.value

“Chat, eu não poderia usar event.target.value aqui?”

Não.
O event.target.value só existe dentro de eventos de input (quando o usuário digita algo).
No caso de prepararEdicao, você não está pegando valor do input — está pegando valor de um objeto existente no array de remédios.
Ou seja: você não precisa ler o que o usuário digitou, e sim preencher o campo com o que já estava no objeto.



⚙️ 2. Função principal: adicionarRemedio():
Essa é a função que controla tanto o adicionar quanto o editar.

function adicionarRemedio(event) {
  event.preventDefault();

  if (nome.trim() !== '' && hora.trim() !== '') {
    const id = remedioEmEdicao || Date.now();

    const novoMedicamento = { id, nome, hora };

    if (remedioEmEdicao) {
      setRemedios((listaAnterior) =>
        listaAnterior.map((remedio) =>
          remedio.id === remedioEmEdicao ? novoMedicamento : remedio
        )
      );
    } else {
      setRemedios((listaAnterior) => [...listaAnterior, novoMedicamento]);
    }

    setNome('');
    setHora('');
    setRemedioEmEdicao(null);
  }
}


🧩 Entendendo o passo a passo:

1️⃣ event.preventDefault()
Evita que o navegador recarregue a página ao enviar o formulário.


2️⃣ const id = remedioEmEdicao || Date.now();
Aqui acontece algo importante:
. Se estivermos editando (remedioEmEdicao tem um valor), ele usa o id existente.
. Se for um novo remédio, ele cria um id novo com Date.now().

🧠 Isso garante que:
. Edições mantêm o mesmo id.
. Novos itens ganham um id novo.


3️⃣ Criando o novo objeto:
const novoMedicamento = { id, nome, hora };

Aqui estamos criando um novo objeto que representa o remédio (seja novo ou atualizado).
Exemplo:

{ id: 17397438493, nome: "Dipirona", hora: "09:00" }



4️⃣ Se estamos editando…
setRemedios((listaAnterior) =>
  listaAnterior.map((remedio) =>
    remedio.id === remedioEmEdicao ? novoMedicamento : remedio
  )
);


🧠 Explicando passo a passo:

. setRemedios → atualiza o estado remedios.
. (listaAnterior) → é o array atual de remédios (antes da mudança).
Esse parâmetro “herda” o valor do estado automaticamente.
. .map() → percorre cada item do array.
. remedio.id === remedioEmEdicao → verifica se o id atual é o que estamos editando.
. ? novoMedicamento : remedio → se for o mesmo id, substitui; se não for, mantém igual.


📘 Exemplo:
Antes:

[
  { id: 1, nome: "Dipirona", hora: "08:00" },
  { id: 2, nome: "Paracetamol", hora: "10:00" }
]


Depois de editar o de id 1:

[
  { id: 1, nome: "Dipirona", hora: "09:00" },
  { id: 2, nome: "Paracetamol", hora: "10:00" }
]



5️⃣ Se for um novo remédio…
setRemedios((listaAnterior) => [...listaAnterior, novoMedicamento]);


🧠 Aqui usamos o spread operator (...):
. Ele copia todos os itens do estado anterior (listaAnterior).
. Depois adiciona o novo medicamento no final.

📘 Exemplo:
Antes:

[{ id: 1, nome: "Dipirona", hora: "08:00" }]


Depois:

[
  { id: 1, nome: "Dipirona", hora: "08:00" },
  { id: 2, nome: "Paracetamol", hora: "10:00" }
]

6️⃣ Limpando os campos
setNome('');
setHora('');
setRemedioEmEdicao(null);


🧠 Isso acontece depois de salvar (tanto edição quanto adição).

setNome('') e setHora('') limpam os inputs.

setRemedioEmEdicao(null) faz o sistema “esquecer” que está editando.
Assim, o botão volta a mostrar “Adicionar” em vez de “Salvar alterações”.


💭 null vs false:

Por que usamos null e não false?
. null significa “não tem valor” (ou “nenhum item em edição”).
. false é um valor lógico, usado em condições booleanas (verdadeiro/falso).
Aqui, não estamos checando uma condição lógica, e sim a ausência de um id — por isso null faz mais sentido.


🧠 Entendendo a origem do id:
“Mas, Chat, de onde vem esse id? Eu não vi ele declarado!”

| O id é criado no momento em que o remédio é adicionado:

const id = Date.now();

Ele é um número baseado na data e hora atual (em milissegundos).
Assim, cada remédio tem um id único — e é esse mesmo id que usamos depois para saber qual item editar.



🎨 3. JSX resumido:
<form onSubmit={adicionarRemedio}>
  <input
    type="text"
    placeholder="Nome do remédio"
    value={nome}
    onChange={(e) => setNome(e.target.value)}
  />
  <input
    type="time"
    value={hora}
    onChange={(e) => setHora(e.target.value)}
  />
  <button type="submit">
    {remedioEmEdicao ? "Salvar edição" : "Adicionar"}
  </button>
</form>

{remedios.map((remedio) => (
  <div key={remedio.id}>
    <p>{remedio.nome}</p>
    <p>{remedio.hora}</p>
    <button onClick={() => prepararEdicao(remedio)}>Editar</button>
  </div>
))}




📘 4. O ciclo completo do editar:
. Usuário adiciona remédio → entra no array.
. Usuário clica em “Editar” → campos são preenchidos.
. Usuário muda o nome ou hora → estados nome e hora atualizam.
. Usuário clica em “Salvar edição” → item é atualizado no estado.
. Campos limpam → volta pro modo normal.



🧩 5. Resumo técnico e prático:
Conceito	                      O que aprendeu
Inputs controlados	            Ligam diretamente o campo ao estado
Imutabilidade	                  Sempre cria um novo array com map ou [...]
Id único	                      Garante que cada item possa ser identificado
Modo de edição	                Controlado via remedioEmEdicao
Null vs False	                  null representa ausência, false representa valor lógico
event.target.value	            Só usado em eventos de input, não pra preencher estados diretamente




💡 6. Exemplo prático com campo extra (observações):

Se você tivesse um novo campo, como “observações”, seria assim:

const [observacao, setObservacao] = useState('');

function prepararEdicao(remedio) {
  setNome(remedio.nome);
  setHora(remedio.hora);
  setObservacao(remedio.observacao || '');
  setRemedioEmEdicao(remedio.id);
}


E ao criar o novo medicamento:

const novoMedicamento = { id, nome, hora, observacao };

Percebe que basta incluir o novo campo no mesmo fluxo — a lógica não muda.





🧩 7. Conclusão:

Essa feature ensina praticamente tudo o que um dev front-end precisa saber 
sobre React e manipulação de estado:

✅ Lidar com inputs controlados
✅ Atualizar listas no estado de forma imutável
✅ Criar e reaproveitar objetos dinamicamente
✅ Usar map com operador ternário para atualizar itens específicos
✅ Entender o uso correto de null, false e event.target.value
✅ E estruturar o código de forma limpa e reaproveitável


























.
🧩 Aula completa — Sistema de sugestões automáticas de medicamentos
🎯 Objetivo da feature

Essa feature faz com que, enquanto o usuário digita o nome de um medicamento, o sistema exiba sugestões automáticas com base em um array de medicamentos já existentes.
Assim que o usuário clica em uma das sugestões, o campo de nome é preenchido automaticamente e a lista desaparece.

Essa funcionalidade melhora muito a experiência do usuário e evita erros de digitação, além de dar uma aparência mais inteligente ao sistema.



🧱 Estrutura geral da feature:
Ela é composta basicamente por três partes principais:

1. Um estado que guarda as sugestões filtradas.
2. Um useEffect que contém toda a lógica de verificação e filtragem conforme o usuário digita.
3. Uma renderização condicional que mostra ou esconde a lista de sugestões conforme as condições.



⚙️ Lógica principal com useEffect:

Versão final e melhorada do código:

useEffect(() => {
  const nomeSemEspacos = nome.trim(); // 🔹 remove espaços extras antes e depois do nome

  // 🧩 Caso o campo esteja vazio → limpa as sugestões e encerra a função
  if (!nomeSemEspacos) {
    setSugestoes([]);
    return;
  }

  // 🧠 Verifica se o nome digitado já é exatamente igual a algum medicamento existente
  const jaExisteMedicamento = medicamentos.some(
    (medicamento) =>
      medicamento.nome.toLowerCase() === nomeSemEspacos.toLowerCase()
  );

  // 🔸 Se for igual, não precisa sugerir nada → limpa as sugestões
  if (jaExisteMedicamento) {
    setSugestoes([]);
    return;
  }

  // 🔍 Filtra medicamentos que comecem com o texto digitado
  const sugestoesFiltradas = medicamentos.filter((medicamento) =>
    medicamento.nome.toLowerCase().startsWith(nomeSemEspacos.toLowerCase())
  );

  // 💾 Atualiza o estado de sugestões
  setSugestoes(sugestoesFiltradas);
}, [nome, medicamentos]);


🧠 Explicação detalhada passo a passo:

- 🔹const nomeSemEspacos = nome.trim():

O método .trim() remove todos os espaços em branco no início e no fim da string.

👉 Isso é importante porque o usuário pode digitar "dipirona " (com espaço no final), 
e sem o .trim() o sistema consideraria "dipirona " diferente de "dipirona".
Assim, trim() evita erros bobos e garante que o filtro funcione corretamente.


- 🔹if (!nomeSemEspacos) { setSugestoes([]); return; }:

Aqui testamos se o campo de nome está vazio depois de remover os espaços.
Se estiver vazio, limpamos a lista de sugestões e interrompemos a execução com return.

. !nomeSemEspacos significa “se nomeSemEspacos for falso”.
. Uma string vazia ("") é considerada falsy no JavaScript.

💡 Por que fazer isso?
Se o usuário apagar tudo o que digitou, não faz sentido mostrar sugestões de medicamentos.



-🔹const jaExisteMedicamento = medicamentos.some(...):

O .some() percorre o array de medicamentos e retorna true se pelo menos um item satisfizer a condição.

Aqui, estamos verificando se o nome digitado já é exatamente igual a um medicamento que existe na lista.

const jaExisteMedicamento = medicamentos.some(
  (medicamento) =>
    medicamento.nome.toLowerCase() === nomeSemEspacos.toLowerCase()
);


Usamos toLowerCase() para evitar diferença entre letras maiúsculas e minúsculas.
Por exemplo: “Dipirona” e “dipirona” devem ser tratados como iguais.

💡 Por que isso existe?
Se o nome digitado já for exatamente igual ao de um medicamento, não faz sentido continuar exibindo sugestões.
Isso evita que a lista continue aparecendo depois que o usuário já selecionou algo válido.



-🔹const sugestoesFiltradas = medicamentos.filter(...):

O método .filter() percorre o array e retorna apenas os itens que passam na condição.

const sugestoesFiltradas = medicamentos.filter((medicamento) =>
  medicamento.nome.toLowerCase().startsWith(nomeSemEspacos.toLowerCase())
);

Usamos startsWith() porque queremos pegar apenas os medicamentos que começam com o texto digitado.
Se o usuário digitar “di”, aparecerão “Dipirona”, “Diclofenaco”, etc.

💡 Diferença importante:
Se usássemos .includes() em vez de .startsWith(), ele retornaria qualquer nome 
que contivesse o texto — mesmo no meio da palavra.
Mas aqui o comportamento ideal é aparecer somente os nomes que começam com o texto digitado.



-🔹setSugestoes(sugestoesFiltradas):

Atualiza o estado sugestoes com o resultado do filtro.
Isso dispara uma nova renderização no React, mostrando as sugestões atualizadas na tela.

🧠 Comparação entre a versão antiga (com erro) e a versão atual (corrigida)
🔸 Filtro de texto

Versão antiga: Usava diretamente o valor de nome.
Problema: Não removia espaços e comparava incorretamente.
Versão corrigida: Usa nome.trim().
Solução: Remove espaços extras antes da comparação.

🔸 Condicional

Versão antiga: Não tratava o caso em que o nome digitado era idêntico a um já existente.
Problema: Sugestões continuavam aparecendo mesmo após selecionar um nome igual.
Versão corrigida: Utiliza some() com toLowerCase().
Solução: Garante que, se o nome já existir, as sugestões sejam limpas.

🔸 Lógica de atualização

Versão antiga: Executava o filtro mesmo quando o campo estava vazio.
Problema: Apareciam sugestões indevidas.
Versão corrigida: Adiciona if (!nomeSemEspacos) antes do filtro.
Solução: Interrompe a execução quando o campo está vazio.





💬 Renderização condicional no JSX
{(sugestoes.length > 0 && nome.trim()) && (
  <ul className="border border-gray-300 rounded mt-1 bg-white shadow">
    {sugestoes.map((s, index) => (
      <li
        key={index}
        onClick={() => {
          setNome(s.nome);
          setSugestoes([]);
        }}
        className="p-2 cursor-pointer hover:bg-blue-100"
      >
        {s.nome}
      </li>
    ))}
  </ul>
)}


Vamos entender cada parte:


-🔹(sugestoes.length > 0 && nome.trim()) && (...):

Isso é a renderização condicional com operador lógico &&.
É a forma mais usada em React para exibir algo apenas quando uma condição for verdadeira.

Funciona assim:
. Se sugestoes.length > 0 for true (ou seja, há pelo menos 1 sugestão)
. E nome.trim() for truthy (ou seja, o campo não está vazio)
. Então o React renderiza o conteúdo dentro dos parênteses (a <ul> com as sugestões).

Se qualquer uma dessas duas condições for falsa → nada é renderizado.


💡 É literalmente como escrever:

if (sugestoes.length > 0 && nome.trim()) {
  return <ul>...</ul>
}


-🔹.map() — criando cada item da lista:
{sugestoes.map((s, index) => (
  <li key={index}> {s.nome} </li>
))}

O método .map() percorre o array sugestoes e cria um elemento JSX para cada item.
. s representa cada sugestão individual (um objeto do tipo { nome: "Dipirona" }).
. {s.nome} mostra o campo nome de cada sugestão.
. key={index} é uma chave única obrigatória no React para listas (ajuda na renderização eficiente).
💡 Se você colocasse só {s} em vez de {s.nome}, apareceria [object Object], porque s é um objeto inteiro.


-🔹onClick={() => { setNome(s.nome); setSugestoes([]); }}:

Esse trecho define o comportamento ao clicar em uma sugestão.
1. setNome(s.nome) → preenche o campo de texto com o nome da sugestão clicada.
2. setSugestoes([]) → limpa o array de sugestões, fazendo a lista desaparecer.
💡 Sem essa segunda linha, as sugestões continuariam aparecendo mesmo após a seleção.

🧩 Resumo dos principais métodos usados

trim() → Remove espaços no início e no fim da string.
📘 Exemplo: " dipirona ".trim() → "dipirona"

toLowerCase() → Converte a string para minúsculas, garantindo que a comparação não falhe por 
causa de letras maiúsculas/minúsculas.
📘 Exemplo: "Dipirona".toLowerCase() → "dipirona"

some() → Verifica se pelo menos um elemento do array satisfaz a condição passada. Retorna true ou false.
📘 Exemplo: [1, 2, 3].some(n => n > 2) → true

filter() → Retorna todos os elementos do array que atendem à condição.
📘 Exemplo: [1, 2, 3].filter(n => n > 2) → [3]

startsWith() → Verifica se uma string começa com os caracteres informados.
📘 Exemplo: "dipirona".startsWith("di") → true

map() → Cria um novo array aplicando uma transformação em cada elemento do array original.
📘 Exemplo: ["a", "b"].map(x => x.toUpperCase()) → ["A", "B"]


🧭 Resumo mental da lógica:

1. O usuário digita algo → o estado nome muda.
2. O useEffect é ativado por causa da dependência [nome].
3. O sistema:
 . remove espaços (trim);
 . verifica se o campo está vazio (if (!nomeSemEspacos));
 . confere se o nome já existe (some);
 . filtra sugestões que começam com o texto (filter + startsWith);
 . atualiza sugestoes.
4. Se houver sugestões → React renderiza a <ul>.
5. Usuário clica em uma → preenche o campo e limpa a lista.

✅ Conclusão final
Essa feature ensina vários fundamentos importantes do React e JavaScript moderno:
. Estados e reatividade com useState e useEffect.
. Renderização condicional com &&.
. Manipulação de arrays e strings (map, filter, some, trim, startsWith).
. Boas práticas de UX, como limpar sugestões e evitar duplicação de nomes.

Com essa base, você consegue replicar a mesma ideia em qualquer outro contexto —
por exemplo, auto-sugestões de cidades, produtos, usuários, categorias, etc.
-->