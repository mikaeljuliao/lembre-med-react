<!--
.

📝 Aula: Salvando e carregando dados com localStorage no React (versão final)

1️⃣ O que é localStorage?
. É um recurso do navegador que guarda dados no próprio computador do usuário.
. Diferente de um banco de dados, só guarda strings (texto).
. Os dados continuam lá mesmo se o usuário fechar ou recarregar a página.

Exemplo simples no console:
localStorage.setItem('nome', 'Mikael'); // salvar
localStorage.getItem('nome');           // "Mikael"


2️⃣ Por que usamos JSON.stringify e JSON.parse?
. O localStorage só aceita texto.
. Nosso estado remedios é um array de objetos.
. Precisamos converter para string para salvar, e converter de volta para objeto para usar.

JSON.stringify(remedios) // transforma array/objeto em string JSON
JSON.parse(string)       // transforma string JSON de volta em array/objeto



3️⃣ A lógica no React:
const [remedios, setRemedios] = useState(() => {
  const dadosSalvos = localStorage.getItem('remedios');
  return dadosSalvos ? JSON.parse(dadosSalvos) : [];
});

useEffect(() => {
  localStorage.setItem("remedios", JSON.stringify(remedios));
}, [remedios]);



4️⃣ Por que usamos useState(() => {...}) com função inicial?
. O React só executa essa função na primeira renderização.
. Com isso, ele lê do localStorage uma única vez e já inicializa remedios com o que estava salvo.
. Sem essa função, você precisaria de dois useEffect: um para carregar e outro para salvar.
. Assim, tudo fica mais limpo.



5️⃣ O operador ternário (condição ? valor1 : valor2):

Dentro do useState usamos:
return dadosSalvos ? JSON.parse(dadosSalvos) : [];


Isso significa:
. Se dadosSalvos existe → converte e retorna os dados.
. Se não existe → retorna um array vazio.


É um jeito curto de escrever:
if (dadosSalvos) {
  return JSON.parse(dadosSalvos);
} else {
  return [];
}



6️⃣ O que significa o [remedios] no useEffect?
. É a lista de dependências.
. O React só roda o useEffect de novo quando algo dessa lista muda.
. Colocando [remedios] → ele roda sempre que remedios mudar.
. Se deixasse [], rodaria só uma vez no início.



7️⃣ Detalhes do localStorage:
. O localStorage.setItem recebe 2 parâmetros:
. Chave: nome do item (string) → 'remedios'.
. Valor: o que quer salvar (também string).

Então:
localStorage.setItem('remedios', JSON.stringify(remedios))

. "remedios" é a chave.
. JSON.stringify(remedios) é o valor salvo (string).


Para ler:
localStorage.getItem('remedios')

. Retorna a string. Se quiser o array de volta, faz:
. JSON.parse(localStorage.getItem('remedios'))



8️⃣ Resumo do fluxo
. Página abre → useState lê localStorage e preenche remedios.
. Usuário adiciona um remédio → setRemedios atualiza o estado.
. useEffect detecta mudança em remedios → salva os novos dados no localStorage.
. Se recarregar a página → useState pega os dados salvos e carrega de volta.


9️⃣ Vantagens dessa abordagem
. Não precisa banco de dados para coisas simples.
. Os dados ficam sempre atualizados sem funções extras.
. Estado inicial já vem com os dados salvos (sem “flash” vazio).
. Evita ter dois useEffect brigando entre si.


💡 Resumo em uma frase:
“O localStorage é um armário do navegador.
Usamos useState para pegar o que está dentro quando o app carrega,
e useEffect para guardar tudo de novo sempre que algo mudar.”
















📚 Aula: Listagem de Medicamentos no React

1. O objetivo da feature:

O que queríamos com essa branch era:
. ✅ Ler um arquivo JSON (medicamentos.json) com dados de medicamentos (nome, dose, frequência, horário etc.).
. ✅ Exibir esses dados automaticamente na tela, sem que o usuário precise cadastrar.
. ✅ Deixar esses dados separados da lógica principal, ou seja, mantê-los no JSON em vez de hardcodar dentro do componente.



2. Preparando os estados:
No React usamos estados (useState) para guardar informações que mudam durante a execução da aplicação.

No começo do componente criamos dois estados:

const [remedios, setRemedios] = useState([]); 
const [medicamentos, setMedicamentos] = useState([]);

. remedios → armazena os medicamentos que o usuário adiciona manualmente no formulário.
. medicamentos → armazena os medicamentos que vêm do arquivo JSON.

Assim conseguimos trabalhar separadamente com cada fonte de dados.



3. Buscando o JSON com useEffect

Para carregar os dados assim que a página abre, usamos o hook useEffect.

useEffect(() => {
  fetch("/medicamentos.json")
    .then((res) => res.json())
    .then((data) => setMedicamentos(data))
    .catch((error) =>
      console.log("Erro ao carregar medicamentos", error)
    );
}, []);

Explicação:
. fetch("/medicamentos.json") → faz a requisição para o arquivo JSON.
. .then(res => res.json()) → transforma a resposta em um objeto JavaScript.
. .then(data => setMedicamentos(data)) → guarda esses dados no estado medicamentos.
. catch(...) → captura possíveis erros.
. O [] no final garante que isso só rode uma vez, quando o componente for montado.



4. Renderizando os medicamentos:

Depois que o JSON foi carregado no estado medicamentos, basta percorrer esse array com .map() e renderizar na tela.

<div className="mt-10">
  <ul>
    {medicamentos.map((medicamento) => (
      <li key={medicamento.id}>
        <strong>
          {medicamento.nome} - {medicamento.dose}
        </strong>{" "}
        <br />
        horário: {medicamento.horario} - frequência:{" "}
        {medicamento.frequencia}
      </li>
    ))}
  </ul>
</div>


O que acontece aqui:
. medicamentos.map(...) → percorre cada item do array.
. key={medicamento.id} → cada item precisa de uma chave única.
. Dentro do JSX mostramos nome, dose, horário e frequência.
. Ou seja, sempre que o arquivo JSON mudar, a interface automaticamente vai refletir esses dados.



5. Integração com a lógica já existente:
Antes, nosso app só cadastrava manualmente com o formulário (remedios).
Agora temos duas listas:

. Lista de remédios cadastrados pelo usuário
. Lista de medicamentos vindos do JSON

Assim a aplicação mostra tanto o que o usuário digitou quanto o que já estava registrado no “banco” de medicamentos.



6. Por que isso é importante?
. 📂 Separação de responsabilidades → os dados ficam em um arquivo externo (JSON).
. ⚡ Reutilização → podemos mudar o JSON sem alterar o código.
. 🔄 Dinamicidade → se o JSON for atualizado, a interface também é.
. 💻 Próxima evolução → no futuro, esse fetch pode vir de uma API real, sem mudar muita coisa no código.


🚀 Conclusão

Na branch listagem-medicamento, aprendemos:
1. Como usar useState para armazenar dados vindos de diferentes fontes.
2. Como usar useEffect + fetch para buscar dados de um JSON.
3. Como percorrer arrays com .map() para renderizar listas no React.
4. Como separar a lógica de medicamentos cadastrados manualmente e carregados automaticamente.

Isso fecha a funcionalidade de listar medicamentos.

Na prática, você agora tem:
. Um mini banco de dados local (JSON).
. Integração desse “banco” com React.
. Exibição dinâmica dos dados.
























🔹 1. git checkout develop

Esse comando faz você entrar na branch develop.

Se já estiver nela, o Git responde algo como Already on 'develop'.

🔹 2. git merge main

Aqui é onde sempre rola confusão 👀

Esse comando pega o histórico da main e junta dentro da develop.

Ou seja: você está atualizando a develop com tudo que já existe na main.

Não é o contrário. A main não recebe nada aqui.

📌 Então:

Branch ativa (onde você está) = quem vai ser atualizada.

Branch do merge (que você passa como argumento) = quem traz as mudanças.

👉 Como você estava em develop, o merge significa:

"junte as mudanças da main dentro da develop".

🔹 3. O que é merge

Exatamente: merge = juntar o histórico de duas branches.
Ele cria um commit especial (merge commit) se houver diferenças entre elas.
Se não houver conflitos, o Git une automaticamente.

📌 Se houver conflitos, você precisa resolver manualmente (como aconteceu antes).

🔹 4. git push origin develop

O push envia a sua branch local (develop) pro repositório remoto (GitHub, GitLab etc.).

origin = apelido padrão pro repositório remoto.

develop = branch que você está enviando.

💡 Se você só fizesse o merge localmente e não desse o push, a develop remota ficaria desatualizada.
O push origin develop garante que a branch remota fique igual à sua local.




✅ Resumindo sua explicação corrigida:
. checkout develop → entro na branch develop.
. merge main → atualizo develop com tudo que está na main.
. push origin develop → envio a develop atualizada pro GitHub.


















🧠 Aula: Criando a funcionalidade Remover Remédio
🎯 Objetivo:

Permitir que o usuário remova um remédio da lista exibida na tela, de forma dinâmica, sem precisar recarregar a página.

🧩 Etapas de implementação
1️⃣ Entendimento do problema

Queríamos que cada remédio adicionado tivesse um botão de remover.
Quando o usuário clicasse, aquele remédio deveria sumir da lista imediatamente.

Pra isso, precisaríamos:
. Acessar o estado atual da lista de remédios (remedios);
. Remover apenas o item selecionado, sem alterar o resto;
. Atualizar o estado pra refletir essa mudança na interface 
(React faz isso automaticamente quando o estado muda).



2️⃣ Criando a função de remover

Usamos o React Hook useState que controla a lista de remédios:

const [remedios, setRemedios] = useState([]);


Depois criamos a função removerRemedio:

function removerRemedio(idDoRemedio) {
  setRemedios((listaAnteriorDeRemedios) => 
    listaAnteriorDeRemedios.filter((remedio) => remedio.id !== idDoRemedio)
  );
}

🧩 Explicando linha por linha:
. setRemedios(...) → é a função que atualiza o estado remedios.
. (listaAnteriorDeRemedios) → é o estado antigo (a lista antes da remoção).
Esse nome é só pra clareza. Em alguns códigos aparece como prev, que é 
abreviação de previous, ou seja, “anterior”.
. .filter() → cria uma nova lista, sem modificar a original, mantendo apenas 
os elementos que passam no teste.
. (remedio) => remedio.id !== idDoRemedio → esse é o teste: só ficam na lista os 
remédios cujo id não é igual ao id que queremos remover.
. O React então re-renderiza o componente mostrando a nova lista, já sem o remédio removido.



3️⃣ Ligando o botão à função:

Dentro do map() que mostra os remédios na tela, adicionamos um botão:

<button
  onClick={() => removerRemedio(remedio.id)}
  className="mt-2 bg-red-500 text-white px-3 py-1 rounded hover:bg-red-600"
>
  Remover
</button>

🧩 O que acontece aqui:
. O onClick chama a função removerRemedio, passando o id do remédio.
. Assim que o botão é clicado, a função roda e o item some da tela.



4️⃣ Testando a funcionalidade:

Passos testados:
1. Adicionar 2 ou mais remédios.
2. Clicar em “Remover” em um deles.
3. Verificar se apenas aquele sumiu da lista.
4. Conferir se o resto da lista continua igual. ✅

🧹 Resultado final (resumo visual)
function removerRemedio(idDoRemedio) {
  setRemedios((listaAnterior) =>
    listaAnterior.filter((remedio) => remedio.id !== idDoRemedio)
  );
}



💡 Resumo conceitual:
.filter() percorre a lista e cria uma nova, com todos os itens que 
não têm o ID igual ao que queremos remover.
Depois setRemedios atualiza o estado com essa nova lista.
O React automaticamente refaz a renderização — e o item desaparece da tela.


📚 Conclusão
. Usamos o conceito de imutabilidade do React: nunca alteramos o 
estado direto, sempre criamos uma nova lista.
. Entendemos o uso do callback no setState, pra trabalhar com o 
valor anterior de forma segura.
. Aplicamos o .filter(), uma função nativa do JavaScript muito 
usada pra manipular arrays no React.



























🧠 Aula Completa – Funcionalidade “Editar Remédio” no React

📘 Objetivo:
Permitir que o usuário adicione, edite e atualize remédios sem criar duplicações, 
mantendo o estado da lista atualizado em tempo real.
Essa funcionalidade representa o “U” do CRUD (Update) — atualizar dados existentes.

🧩 Estrutura base:
Antes de tudo, o componente tem os seguintes estados:

const [nome, setNome] = useState("");
const [hora, setHora] = useState("");
const [remedios, setRemedios] = useState([]);
const [remedioEmEdicao, setRemedioEmEdicao] = useState(null);

🔍 O que cada um faz:
Estado            	Função
nome	              Guarda o texto digitado no input de nome do remédio
hora	              Guarda o horário escolhido
remedios           	É um array com todos os remédios cadastrados
                   (cada item é um objeto com id, nome e hora)
remedioEmEdicaovvv	Guarda o id do remédio que está sendo editado. Quando está null, 
                   quer dizer que não estamos editando nada.




🧱 1. Entendendo a função prepararEdicao():
Essa função é chamada quando clicamos no botão “Editar” de algum remédio:

function prepararEdicao(remedio) {
  setHora(remedio.hora);
  setNome(remedio.nome);
  setRemedioEmEdicao(remedio.id);
}

🧩 Linha por linha:

1. setHora(remedio.hora)
→ Pega o valor da propriedade hora do objeto remedio e joga dentro do estado hora.
Isso faz com que o input <input type="time" value={hora} /> seja preenchido automaticamente 
com o horário do remédio.

2. setNome(remedio.nome)
→ Faz a mesma coisa para o nome.
Ou seja, os campos do formulário são “preenchidos” automaticamente.

3. setRemedioEmEdicao(remedio.id)
→ Define qual remédio estamos editando, guardando o id dele.
Esse id é único e foi criado lá na hora que adicionamos o remédio.
Se estivermos editando o item de id 3, por exemplo, o estado remedioEmEdicao vai virar 3.


🧠 Analogia:
Pense assim:
quando você clica em “Editar”, o React pega aquele objeto do array e fala:

“Ok, Mikael, agora vou colocar o nome e a hora desse item nos campos, e 
guardar o id dele pra saber que esse é o cara que estamos mexendo.”


💬 Sua dúvida sobre event.target.value

“Chat, eu não poderia usar event.target.value aqui?”

Não.
O event.target.value só existe dentro de eventos de input (quando o usuário digita algo).
No caso de prepararEdicao, você não está pegando valor do input — está pegando valor de um objeto existente no array de remédios.
Ou seja: você não precisa ler o que o usuário digitou, e sim preencher o campo com o que já estava no objeto.



⚙️ 2. Função principal: adicionarRemedio():
Essa é a função que controla tanto o adicionar quanto o editar.

function adicionarRemedio(event) {
  event.preventDefault();

  if (nome.trim() !== '' && hora.trim() !== '') {
    const id = remedioEmEdicao || Date.now();

    const novoMedicamento = { id, nome, hora };

    if (remedioEmEdicao) {
      setRemedios((listaAnterior) =>
        listaAnterior.map((remedio) =>
          remedio.id === remedioEmEdicao ? novoMedicamento : remedio
        )
      );
    } else {
      setRemedios((listaAnterior) => [...listaAnterior, novoMedicamento]);
    }

    setNome('');
    setHora('');
    setRemedioEmEdicao(null);
  }
}


🧩 Entendendo o passo a passo:

1️⃣ event.preventDefault()
Evita que o navegador recarregue a página ao enviar o formulário.


2️⃣ const id = remedioEmEdicao || Date.now();
Aqui acontece algo importante:
. Se estivermos editando (remedioEmEdicao tem um valor), ele usa o id existente.
. Se for um novo remédio, ele cria um id novo com Date.now().

🧠 Isso garante que:
. Edições mantêm o mesmo id.
. Novos itens ganham um id novo.


3️⃣ Criando o novo objeto:
const novoMedicamento = { id, nome, hora };

Aqui estamos criando um novo objeto que representa o remédio (seja novo ou atualizado).
Exemplo:

{ id: 17397438493, nome: "Dipirona", hora: "09:00" }



4️⃣ Se estamos editando…
setRemedios((listaAnterior) =>
  listaAnterior.map((remedio) =>
    remedio.id === remedioEmEdicao ? novoMedicamento : remedio
  )
);


🧠 Explicando passo a passo:

. setRemedios → atualiza o estado remedios.
. (listaAnterior) → é o array atual de remédios (antes da mudança).
Esse parâmetro “herda” o valor do estado automaticamente.
. .map() → percorre cada item do array.
. remedio.id === remedioEmEdicao → verifica se o id atual é o que estamos editando.
. ? novoMedicamento : remedio → se for o mesmo id, substitui; se não for, mantém igual.


📘 Exemplo:
Antes:

[
  { id: 1, nome: "Dipirona", hora: "08:00" },
  { id: 2, nome: "Paracetamol", hora: "10:00" }
]


Depois de editar o de id 1:

[
  { id: 1, nome: "Dipirona", hora: "09:00" },
  { id: 2, nome: "Paracetamol", hora: "10:00" }
]



5️⃣ Se for um novo remédio…
setRemedios((listaAnterior) => [...listaAnterior, novoMedicamento]);


🧠 Aqui usamos o spread operator (...):
. Ele copia todos os itens do estado anterior (listaAnterior).
. Depois adiciona o novo medicamento no final.

📘 Exemplo:
Antes:

[{ id: 1, nome: "Dipirona", hora: "08:00" }]


Depois:

[
  { id: 1, nome: "Dipirona", hora: "08:00" },
  { id: 2, nome: "Paracetamol", hora: "10:00" }
]

6️⃣ Limpando os campos
setNome('');
setHora('');
setRemedioEmEdicao(null);


🧠 Isso acontece depois de salvar (tanto edição quanto adição).

setNome('') e setHora('') limpam os inputs.

setRemedioEmEdicao(null) faz o sistema “esquecer” que está editando.
Assim, o botão volta a mostrar “Adicionar” em vez de “Salvar alterações”.


💭 null vs false:

Por que usamos null e não false?
. null significa “não tem valor” (ou “nenhum item em edição”).
. false é um valor lógico, usado em condições booleanas (verdadeiro/falso).
Aqui, não estamos checando uma condição lógica, e sim a ausência de um id — por isso null faz mais sentido.


🧠 Entendendo a origem do id:
“Mas, Chat, de onde vem esse id? Eu não vi ele declarado!”

| O id é criado no momento em que o remédio é adicionado:

const id = Date.now();

Ele é um número baseado na data e hora atual (em milissegundos).
Assim, cada remédio tem um id único — e é esse mesmo id que usamos depois para saber qual item editar.



🎨 3. JSX resumido:
<form onSubmit={adicionarRemedio}>
  <input
    type="text"
    placeholder="Nome do remédio"
    value={nome}
    onChange={(e) => setNome(e.target.value)}
  />
  <input
    type="time"
    value={hora}
    onChange={(e) => setHora(e.target.value)}
  />
  <button type="submit">
    {remedioEmEdicao ? "Salvar edição" : "Adicionar"}
  </button>
</form>

{remedios.map((remedio) => (
  <div key={remedio.id}>
    <p>{remedio.nome}</p>
    <p>{remedio.hora}</p>
    <button onClick={() => prepararEdicao(remedio)}>Editar</button>
  </div>
))}




📘 4. O ciclo completo do editar:
. Usuário adiciona remédio → entra no array.
. Usuário clica em “Editar” → campos são preenchidos.
. Usuário muda o nome ou hora → estados nome e hora atualizam.
. Usuário clica em “Salvar edição” → item é atualizado no estado.
. Campos limpam → volta pro modo normal.



🧩 5. Resumo técnico e prático:
Conceito	                      O que aprendeu
Inputs controlados	            Ligam diretamente o campo ao estado
Imutabilidade	                  Sempre cria um novo array com map ou [...]
Id único	                      Garante que cada item possa ser identificado
Modo de edição	                Controlado via remedioEmEdicao
Null vs False	                  null representa ausência, false representa valor lógico
event.target.value	            Só usado em eventos de input, não pra preencher estados diretamente




💡 6. Exemplo prático com campo extra (observações):

Se você tivesse um novo campo, como “observações”, seria assim:

const [observacao, setObservacao] = useState('');

function prepararEdicao(remedio) {
  setNome(remedio.nome);
  setHora(remedio.hora);
  setObservacao(remedio.observacao || '');
  setRemedioEmEdicao(remedio.id);
}


E ao criar o novo medicamento:

const novoMedicamento = { id, nome, hora, observacao };

Percebe que basta incluir o novo campo no mesmo fluxo — a lógica não muda.





🧩 7. Conclusão:

Essa feature ensina praticamente tudo o que um dev front-end precisa saber 
sobre React e manipulação de estado:

✅ Lidar com inputs controlados
✅ Atualizar listas no estado de forma imutável
✅ Criar e reaproveitar objetos dinamicamente
✅ Usar map com operador ternário para atualizar itens específicos
✅ Entender o uso correto de null, false e event.target.value
✅ E estruturar o código de forma limpa e reaproveitável


























.
🧩 Aula completa — Sistema de sugestões automáticas de medicamentos
🎯 Objetivo da feature

Essa feature faz com que, enquanto o usuário digita o nome de um medicamento, o sistema exiba sugestões automáticas com base em um array de medicamentos já existentes.
Assim que o usuário clica em uma das sugestões, o campo de nome é preenchido automaticamente e a lista desaparece.

Essa funcionalidade melhora muito a experiência do usuário e evita erros de digitação, além de dar uma aparência mais inteligente ao sistema.



🧱 Estrutura geral da feature:
Ela é composta basicamente por três partes principais:

1. Um estado que guarda as sugestões filtradas.
2. Um useEffect que contém toda a lógica de verificação e filtragem conforme o usuário digita.
3. Uma renderização condicional que mostra ou esconde a lista de sugestões conforme as condições.



⚙️ Lógica principal com useEffect:

Versão final e melhorada do código:

useEffect(() => {
  const nomeSemEspacos = nome.trim(); // 🔹 remove espaços extras antes e depois do nome

  // 🧩 Caso o campo esteja vazio → limpa as sugestões e encerra a função
  if (!nomeSemEspacos) {
    setSugestoes([]);
    return;
  }

  // 🧠 Verifica se o nome digitado já é exatamente igual a algum medicamento existente
  const jaExisteMedicamento = medicamentos.some(
    (medicamento) =>
      medicamento.nome.toLowerCase() === nomeSemEspacos.toLowerCase()
  );

  // 🔸 Se for igual, não precisa sugerir nada → limpa as sugestões
  if (jaExisteMedicamento) {
    setSugestoes([]);
    return;
  }

  // 🔍 Filtra medicamentos que comecem com o texto digitado
  const sugestoesFiltradas = medicamentos.filter((medicamento) =>
    medicamento.nome.toLowerCase().startsWith(nomeSemEspacos.toLowerCase())
  );

  // 💾 Atualiza o estado de sugestões
  setSugestoes(sugestoesFiltradas);
}, [nome, medicamentos]);


🧠 Explicação detalhada passo a passo:

- 🔹const nomeSemEspacos = nome.trim():

O método .trim() remove todos os espaços em branco no início e no fim da string.

👉 Isso é importante porque o usuário pode digitar "dipirona " (com espaço no final), 
e sem o .trim() o sistema consideraria "dipirona " diferente de "dipirona".
Assim, trim() evita erros bobos e garante que o filtro funcione corretamente.


- 🔹if (!nomeSemEspacos) { setSugestoes([]); return; }:

Aqui testamos se o campo de nome está vazio depois de remover os espaços.
Se estiver vazio, limpamos a lista de sugestões e interrompemos a execução com return.

. !nomeSemEspacos significa “se nomeSemEspacos for falso”.
. Uma string vazia ("") é considerada falsy no JavaScript.

💡 Por que fazer isso?
Se o usuário apagar tudo o que digitou, não faz sentido mostrar sugestões de medicamentos.



-🔹const jaExisteMedicamento = medicamentos.some(...):

O .some() percorre o array de medicamentos e retorna true se pelo menos um item satisfizer a condição.

Aqui, estamos verificando se o nome digitado já é exatamente igual a um medicamento que existe na lista.

const jaExisteMedicamento = medicamentos.some(
  (medicamento) =>
    medicamento.nome.toLowerCase() === nomeSemEspacos.toLowerCase()
);


Usamos toLowerCase() para evitar diferença entre letras maiúsculas e minúsculas.
Por exemplo: “Dipirona” e “dipirona” devem ser tratados como iguais.

💡 Por que isso existe?
Se o nome digitado já for exatamente igual ao de um medicamento, não faz sentido continuar exibindo sugestões.
Isso evita que a lista continue aparecendo depois que o usuário já selecionou algo válido.



-🔹const sugestoesFiltradas = medicamentos.filter(...):

O método .filter() percorre o array e retorna apenas os itens que passam na condição.

const sugestoesFiltradas = medicamentos.filter((medicamento) =>
  medicamento.nome.toLowerCase().startsWith(nomeSemEspacos.toLowerCase())
);

Usamos startsWith() porque queremos pegar apenas os medicamentos que começam com o texto digitado.
Se o usuário digitar “di”, aparecerão “Dipirona”, “Diclofenaco”, etc.

💡 Diferença importante:
Se usássemos .includes() em vez de .startsWith(), ele retornaria qualquer nome 
que contivesse o texto — mesmo no meio da palavra.
Mas aqui o comportamento ideal é aparecer somente os nomes que começam com o texto digitado.



-🔹setSugestoes(sugestoesFiltradas):

Atualiza o estado sugestoes com o resultado do filtro.
Isso dispara uma nova renderização no React, mostrando as sugestões atualizadas na tela.

🧠 Comparação entre a versão antiga (com erro) e a versão atual (corrigida)
🔸 Filtro de texto

Versão antiga: Usava diretamente o valor de nome.
Problema: Não removia espaços e comparava incorretamente.
Versão corrigida: Usa nome.trim().
Solução: Remove espaços extras antes da comparação.

🔸 Condicional

Versão antiga: Não tratava o caso em que o nome digitado era idêntico a um já existente.
Problema: Sugestões continuavam aparecendo mesmo após selecionar um nome igual.
Versão corrigida: Utiliza some() com toLowerCase().
Solução: Garante que, se o nome já existir, as sugestões sejam limpas.

🔸 Lógica de atualização

Versão antiga: Executava o filtro mesmo quando o campo estava vazio.
Problema: Apareciam sugestões indevidas.
Versão corrigida: Adiciona if (!nomeSemEspacos) antes do filtro.
Solução: Interrompe a execução quando o campo está vazio.





💬 Renderização condicional no JSX
{(sugestoes.length > 0 && nome.trim()) && (
  <ul className="border border-gray-300 rounded mt-1 bg-white shadow">
    {sugestoes.map((s, index) => (
      <li
        key={index}
        onClick={() => {
          setNome(s.nome);
          setSugestoes([]);
        }}
        className="p-2 cursor-pointer hover:bg-blue-100"
      >
        {s.nome}
      </li>
    ))}
  </ul>
)}


Vamos entender cada parte:


-🔹(sugestoes.length > 0 && nome.trim()) && (...):

Isso é a renderização condicional com operador lógico &&.
É a forma mais usada em React para exibir algo apenas quando uma condição for verdadeira.

Funciona assim:
. Se sugestoes.length > 0 for true (ou seja, há pelo menos 1 sugestão)
. E nome.trim() for truthy (ou seja, o campo não está vazio)
. Então o React renderiza o conteúdo dentro dos parênteses (a <ul> com as sugestões).

Se qualquer uma dessas duas condições for falsa → nada é renderizado.


💡 É literalmente como escrever:

if (sugestoes.length > 0 && nome.trim()) {
  return <ul>...</ul>
}


-🔹.map() — criando cada item da lista:
{sugestoes.map((s, index) => (
  <li key={index}> {s.nome} </li>
))}

O método .map() percorre o array sugestoes e cria um elemento JSX para cada item.
. s representa cada sugestão individual (um objeto do tipo { nome: "Dipirona" }).
. {s.nome} mostra o campo nome de cada sugestão.
. key={index} é uma chave única obrigatória no React para listas (ajuda na renderização eficiente).
💡 Se você colocasse só {s} em vez de {s.nome}, apareceria [object Object], porque s é um objeto inteiro.


-🔹onClick={() => { setNome(s.nome); setSugestoes([]); }}:

Esse trecho define o comportamento ao clicar em uma sugestão.
1. setNome(s.nome) → preenche o campo de texto com o nome da sugestão clicada.
2. setSugestoes([]) → limpa o array de sugestões, fazendo a lista desaparecer.
💡 Sem essa segunda linha, as sugestões continuariam aparecendo mesmo após a seleção.

🧩 Resumo dos principais métodos usados

trim() → Remove espaços no início e no fim da string.
📘 Exemplo: " dipirona ".trim() → "dipirona"

toLowerCase() → Converte a string para minúsculas, garantindo que a comparação não falhe por 
causa de letras maiúsculas/minúsculas.
📘 Exemplo: "Dipirona".toLowerCase() → "dipirona"

some() → Verifica se pelo menos um elemento do array satisfaz a condição passada. Retorna true ou false.
📘 Exemplo: [1, 2, 3].some(n => n > 2) → true

filter() → Retorna todos os elementos do array que atendem à condição.
📘 Exemplo: [1, 2, 3].filter(n => n > 2) → [3]

startsWith() → Verifica se uma string começa com os caracteres informados.
📘 Exemplo: "dipirona".startsWith("di") → true

map() → Cria um novo array aplicando uma transformação em cada elemento do array original.
📘 Exemplo: ["a", "b"].map(x => x.toUpperCase()) → ["A", "B"]


🧭 Resumo mental da lógica:

1. O usuário digita algo → o estado nome muda.
2. O useEffect é ativado por causa da dependência [nome].
3. O sistema:
 . remove espaços (trim);
 . verifica se o campo está vazio (if (!nomeSemEspacos));
 . confere se o nome já existe (some);
 . filtra sugestões que começam com o texto (filter + startsWith);
 . atualiza sugestoes.
4. Se houver sugestões → React renderiza a <ul>.
5. Usuário clica em uma → preenche o campo e limpa a lista.

✅ Conclusão final
Essa feature ensina vários fundamentos importantes do React e JavaScript moderno:
. Estados e reatividade com useState e useEffect.
. Renderização condicional com &&.
. Manipulação de arrays e strings (map, filter, some, trim, startsWith).
. Boas práticas de UX, como limpar sugestões e evitar duplicação de nomes.

Com essa base, você consegue replicar a mesma ideia em qualquer outro contexto —
por exemplo, auto-sugestões de cidades, produtos, usuários, categorias, etc.




















🧠 Aula: Feature — Adicionar Data e Hora ao Adicionar um Novo Medicamento
🎯 Objetivo da funcionalidade

Quando o usuário adiciona um novo remédio, o sistema deve registrar automaticamente a 
data e hora exata em que o medicamento foi adicionado, mostrando essa informação 
junto com os dados do remédio.


🧩 1. Onde essa lógica entra no código:

A lógica foi implementada dentro da função adicionarRemedio,
que é executada quando o usuário clica em “Adicionar”.

Essa função já criava um novo objeto novoMedicamento, e é exatamente nesse ponto que 
incluímos a nova propriedade dataAdicao.




💡 2. A criação da data formatada:

Antes de montar o objeto do novo remédio, criamos a data e a hora atuais:

const agora = new Date(); // cria uma data com o momento atual
const dataFormatada = agora.toLocaleString("pt-BR", {
  day: "2-digit",
  month: "2-digit",
  year: "numeric",
  hour: "2-digit",
  minute: "2-digit",
});

🧠 Explicando:

. new Date() → cria um objeto com a data e hora atuais do sistema.
. toLocaleString("pt-BR", {...}) → formata a data no padrão brasileiro (ex: 23/10/2025, 14:32).
. As opções passadas (day, month, year, hour, minute) garantem que o formato fique legível.



🧱 3. Montando o objeto novoMedicamento com data e hora:

Abaixo está o trecho principal:

const novoMedicamento = medicamentoEncontrado
  ? { ...medicamentoEncontrado, hora, id, dataAdicao: dataFormatada }
  : { id, nome, hora, dosagem, observacao, dataAdicao: dataFormatada };

🧩 Explicando o que acontece:
1. O operador ternário (? :) decide qual objeto criar:
. Se o remédio já existe no JSON (medicamentoEncontrado), ele copia 
os dados com o spread operator (...medicamentoEncontrado) e adiciona/atualiza os campos necessários.
. Se for um remédio novo, ele cria um novo objeto do zero.

2. Em ambos os casos, adicionamos:
jsx:
dataAdicao: dataFormatada

Ou seja, toda vez que um remédio for adicionado, será registrado com o 
campo dataAdicao contendo a data e hora da adição.



🔎 4. O operador ternário com objetos (detalhado):

Como o ternário retorna valores, você pode retornar qualquer tipo de dado — incluindo objetos.

💬 Exemplo simples:

const usuarioLogado = true;

const perfil = usuarioLogado
  ? { nome: "Mikael", status: "online" }
  : { nome: "Visitante", status: "offline" };

console.log(perfil);
// → { nome: "Mikael", status: "online" }


🧩 No nosso caso:
. Se encontrou o medicamento → cria um objeto baseado nele.
. Se não → cria um novo objeto manualmente.
. Em ambos → adiciona a propriedade dataAdicao.



🧰 5. Exibindo a data na interface:

Depois de adicionar a propriedade ao estado, basta mostrar no JSX:

<p className="text-sm text-gray-600">
  📅 Adicionado em: {remedio.dataAdicao}
</p>

Se o medicamento foi adicionado agora, vai aparecer algo como:

📅 Adicionado em: 23/10/2025 17:42




⚙️ 6. Ciclo completo da lógica:
Etapa	                          O que acontece
🟢 1.                          Usuário clica em “Adicionar”	Executa adicionarRemedio()
🕓 2.                          Sistema cria new Date()	Gera data/hora atual
🧩 3.                          Formata data/hora	Deixa no formato dd/mm/aaaa hh:mm
💾 4.                          Cria novoMedicamento com dataAdicao	Adiciona a nova propriedade ao objeto
📦 5.                          Atualiza o estado remedios	O React re-renderiza a tela
🖥️ 6.                          Exibe na interface a data/hora	Mostra visualmente ao usuário



🧠 7.Principais métodos usados:

Método	                     O que faz	                          Exemplo
new Date()	                 Cria um objeto representando a       new Date() → Thu Oct 23 2025 17:42:10 GMT...
                             data/hora atual.	
toLocaleString()	           Formata data/hora conforme o         new Date().toLocaleString("pt-BR")
                             idioma e opções.	                    → "23/10/2025 17:42"
? : (ternário)	             Retorna um valor entre duas          condicao ? valor1 : valor2
                             opções conforme uma condição.	
... (spread operator)	       Copia as propriedades de um objeto   { ...user, idade: 25 }
                             existente.	



✅ 8. Resultado final:

Ao adicionar um remédio:
. Ele aparece na lista com a data e hora de adição.
. O valor é salvo junto aos outros dados (e mantido no localStorage também).
. Cada medicamento terá seu próprio campo dataAdicao, registrado no momento exato da criação.

💬 Resumo conceitual

Toda vez que adicionamos um novo item, podemos registrar 
metadados — informações sobre o evento em si (como data/hora de criação, ID, autor etc).
Essa prática é muito usada em sistemas reais, porque ajuda a rastrear
quando as coisas foram criadas ou modificadas.





























.

📘 Aula Completa: Funcionalidade de Histórico de Medicamentos (Versão Inicial)
🧭 1. Objetivo da funcionalidade

Essa funcionalidade registra cada medicamento adicionado na lista, permitindo que 
o usuário mantenha um histórico de adições, mesmo após fechar o aplicativo.

🎯 O que ela faz:
. Registra nome, dosagem, horário e data exata em que o remédio foi adicionado.
. Mantém os dados persistentes no navegador via localStorage.
. Exibe uma lista completa com todos os medicamentos já adicionados.

💡 Importante:
Esta é a versão inicial.
Ainda não registra remoções, alarmes ou contagem regressiva, mas 
serve como base sólida para evoluir futuramente com:
. Registro de medicamentos tomados/removidos
. Filtros e ordenação
. Exportação do histórico




🧩 2. Estrutura geral da lógica:
1. O fluxo principal é dividido em quatro etapas:
2. Estados e carregamento inicial (useState)
3. Persistência automática (useEffect)
4. Função de adicionar medicamento (adicionarRemedio)



Renderização e exibição do histórico (JSX):

⚙️ 3. Estados iniciais e carregamento (useState)
Declaração dos estados:
const [remedios, setRemedios] = useState(() => {
  const salv = localStorage.getItem("dadosRemedios");
  return salv ? JSON.parse(salv) : [];
});

const [historico, setHistorico] = useState(() => {
  const salv = localStorage.getItem("historicoMedicamento");
  return salv ? JSON.parse(salv) : [];
});


🔍 Entendendo a lógica:
. useState aqui recebe uma função de inicialização.
Essa função só é executada uma vez — quando o componente é montado.
Isso evita ler o localStorage a cada renderização.

. localStorage.getItem("dadosRemedios"):
busca os remédios que estavam salvos da última sessão.

. JSON.parse(salv):
converte o texto do localStorage de volta em um array de objetos JavaScript.

. Se não encontrar nada (null), inicializa com [] (array vazio).




💡 Diferença entre os estados:
Estado	                                 Finalidade
remedios                                 Lista ativa: o que o usuário adicionou e ainda está em uso
historico	                               Lista permanente: tudo o que já foi adicionado, 
                                         mesmo que depois seja removido


🔁 4. Persistência automática (useEffect)

Cada lista tem seu próprio efeito de salvamento:

useEffect(() => {
  localStorage.setItem("dadosRemedios", JSON.stringify(remedios));
}, [remedios]);

useEffect(() => {
  localStorage.setItem("historicoMedicamento", JSON.stringify(historico));
}, [historico]);


🧠 Por que separar?
Antes, talvez você tentasse salvar os dois estados num mesmo setItem, mas isso não é ideal.
O localStorage trabalha com chaves independentes — cada uma guarda apenas um valor.

Então criamos dois useEffect separados, um para cada estado.
Assim:
. remedios salva com a chave "dadosRemedios"
. historico salva com a chave "historicoMedicamento"

✅ Vantagens:
. Evita sobrescrever dados acidentalmente.
. Cada estado é controlado de forma isolada.
. As listas persistem corretamente entre sessões.



➕ 5. Função adicionarRemedio() — a lógica central
function adicionarRemedio(event) {
  event.preventDefault();

  if (!nome.trim() || !hora.trim() || !dosagem.trim()) return;

  const dataAtual = new Date();
  const dataFormatada = dataAtual.toLocaleString("pt-BR", {
    day: "2-digit",
    month: "2-digit",
    year: "numeric",
    hour: "2-digit",
    minute: "2-digit",
  });

  const id = Date.now(); // id único baseado no timestamp

  const novoMedicamento = {
    id,
    nome,
    hora,
    dosagem,
    observacao,
    dataAdicaoAtual: dataFormatada,
  };

  setRemedios(prev => [...prev, novoMedicamento]);
  setHistorico(prev => [...prev, novoMedicamento]);

  setNome("");
  setHora("");
  setDosagem("");
  setObservacao("");
}

🔍 Passo a passo detalhado:

1. Prevenir o comportamento padrão do formulário com event.preventDefault(), 
para não recarregar a página.

2. Validação:
Se algum campo obrigatório estiver vazio (!nome.trim() etc.), interrompe a função com return.

3. Data e hora formatadas:
Usa new Date() e .toLocaleString("pt-BR") para gerar uma data no formato brasileiro, por exemplo:
28/10/2025 21:54.

4. ID único:
Date.now() cria um número baseado no timestamp atual (garante que cada remédio tenha um id exclusivo).

5. Criação do objeto:
const novoMedicamento = { id, nome, hora, dosagem, observacao, dataAdicaoAtual }

Esse objeto representa um registro completo da adição do remédio.

6. Atualização dos estados:

setRemedios(prev => [...prev, novoMedicamento]);
setHistorico(prev => [...prev, novoMedicamento]);

. O React atualiza estados de forma assíncrona, então usamos o padrão 
prev => [...prev, novo] pra garantir que o novo valor é adicionado sobre o anterior, 
sem sobrescrever.
. Assim, cada novo medicamento é anexado à lista existente, e não substitui o conteúdo antigo.

7. Limpeza dos campos de input com os set vazios — isso prepara o formulário pro próximo registro.



🖥️ 6. Renderização e interface do histórico (JSX):
<div className="mt-10 bg-white p-4 rounded shadow">
  <h2 className="text-2xl font-bold text-blue-700 mb-4">📜 Histórico de Medicamentos</h2>
  {historico.length === 0 ? (
    <p className="text-gray-600">Nenhum medicamento adicionado ainda.</p>
  ) : (
    <ul>
      {historico.map((item) => (
        <li key={item.id} className="border-b border-gray-200 py-2">
          <strong>{item.nome}</strong> — {item.dosagem}  
          <br />
          ⏰ {item.hora} | 📅 {item.dataAdicaoAtual}
        </li>
      ))}
    </ul>
  )}
</div>

🧠 O que acontece aqui:
. historico.length === 0 → mostra mensagem amigável quando o histórico está vazio.
. historico.map() → percorre todos os registros e renderiza um <li> pra cada medicamento.
. key={item.id} → é obrigatório pro React identificar cada item da lista.
. Exibe as informações de forma simples e direta, com ícones e data formatada.



🧱 7. Código base completo (resumo compacto):
// Estados
const [remedios, setRemedios] = useState(() => JSON.parse(localStorage.getItem("dadosRemedios")) || []);
const [historico, setHistorico] = useState(() => JSON.parse(localStorage.getItem("historicoMedicamento")) || []);

// Salvamento automático
useEffect(() => localStorage.setItem("dadosRemedios", JSON.stringify(remedios)), [remedios]);
useEffect(() => localStorage.setItem("historicoMedicamento", JSON.stringify(historico)), [historico]);

// Adição
function adicionarRemedio(e) {
  e.preventDefault();
  if (!nome.trim() || !hora.trim() || !dosagem.trim()) return;

  const novoMedicamento = {
    id: Date.now(),
    nome,
    hora,
    dosagem,
    observacao,
    dataAdicaoAtual: new Date().toLocaleString("pt-BR"),
  };

  setRemedios(prev => [...prev, novoMedicamento]);
  setHistorico(prev => [...prev, novoMedicamento]);
  setNome(""); setHora(""); setDosagem(""); setObservacao("");
}



🧩 8. Erros comuns e soluções:
  Problema	                         Efeito observado	                             Solução
. setHistorico(novo) ao invés de     Histórico sobrescreve e mostra só o 	         Sempre usar função com prev
prev => [...prev, novo]	             último registro
Chaves de localStorage trocadas	     Dados aparecem no localStorage mas não        "dadosRemedios" e "historicoMedicamento"
                                     exibem no histórico	Usar nomes consistentes: 
Falta de useEffect para salvar	     Histórico some ao fechar o app	                Usar useEffect separado para cada estado
Renderizar histórico fora da         Histórico aparece “fora” do layout visual	    Colocar dentro do mesmo container principal
hierarquia
Campos vazios	                       Adiciona itens incompletos	                    Validar com `if (!nome.trim()




🧠 9. Entendendo a lógica interna (em palavras):
. Quando o app carrega, ele busca o que estava salvo no localStorage e repassa pro estado.
. Quando o usuário adiciona um remédio, o app:
  1. Cria o objeto completo do remédio.
  2. Adiciona esse objeto tanto à lista principal quanto ao histórico.
  3. O React atualiza o estado → o useEffect detecta a mudança → o localStorage é atualizado.
. O histórico então é renderizado automaticamente com os dados mais recentes.
. Se recarregar a página, o useState inicial recupera tudo salvo.




💡 10. Principais aprendizados técnicos:
Conceito	                              Explicação
Função no useState	                    Executa só uma vez — ótima pra inicializar dados do localStorage.
Dois useEffect separados	              Evita conflito e garante salvamento correto de cada estado.
setState(prev => [...prev, novo])	      Adiciona novos itens sem sobrescrever os anteriores.
localStorage como cache local	          Garante persistência entre sessões sem backend.
toLocaleString("pt-BR")	                Facilita exibição de data/hora no formato brasileiro.




🏁 Conclusão:
Essa é a primeira versão funcional e estável do histórico de medicamentos.
Ela resolve a base de registro de ações e persistência de dados, servindo de 
fundação para as próximas funcionalidades como contagem regressiva e alarmes.





































🧭 Aula 1 — Como criar uma contagem regressiva com React passo a passo
🎯 Objetivo

Aprender a criar uma contagem regressiva funcional no React, entendendo cada etapa 
do código — desde os estados, funções e efeitos colaterais até a formatação final do tempo.

A ideia é que, ao final, você consiga reproduzir e adaptar esse cronômetro em qualquer projeto.

🧩 Parte 1 — Criando os estados principais

No React, usamos useState para armazenar valores que mudam ao longo do tempo — e que, 
quando mudam, fazem a interface atualizar automaticamente.

const [duracaoEmHoras, setDuracaoEmHoras] = useState(0);
const [milissegundosConvertidos, setMilissegundosConvertidos] = useState(0);
const [tempoRestante, setTempoRestante] = useState(0);
const [contando, setContando] = useState(false);

🧠 Explicando cada um:
. duracaoEmHoras → quanto tempo (em horas) o usuário quer contar.
. milissegundosConvertidos → o valor de horas convertido em milissegundos (ms).
. tempoRestante → o tempo que ainda falta, também em milissegundos.
. contando → indica se o cronômetro está ativo (true) ou parado (false).

Esses estados são a base do nosso contador.



⏱️ Parte 2 — Criando o botão de início/parada:

Podemos ter um botão que inicie e pare a contagem:

function alternarContagem() {
  setContando(!contando);
}


🧠 Explicação:
. Esse código inverte o valor de contando.
Se estava false, vira true, e vice-versa.
Assim conseguimos iniciar e pausar o cronômetro.




⏲️ Parte 3 — Convertendo horas para milissegundos:

Antes de começar a contagem, precisamos transformar o valor em 
milissegundos, porque o setInterval trabalha com essa unidade.

function converterDuracaoParaMs() {
  const ms = duracaoEmHoras * 60 * 60 * 1000;
  setMilissegundosConvertidos(ms);
  setTempoRestante(ms);
}

🔍 Explicando passo a passo
Etapa                    	Conversão           	    Cálculo         	Resultado
1	                       1 hora → minutos      	    1 × 60	          60 minutos
2	                       1 minuto → segundos	      60 × 60	          3600 segundos
3	                       1 segundo → milissegundos	3600 × 1000	      3.600.000 ms

✅ 1 hora = 3.600.000 milissegundos

Se forem 2 horas, basta multiplicar:
2 × 3.600.000 = 7.200.000 ms


🧠 Entendendo a função:
. duracaoEmHoras * 60 * 60 * 1000 → converte o valor digitado (em horas) 
para milissegundos.
. setMilissegundosConvertidos(ms) → guarda esse valor convertido.
. setTempoRestante(ms) → define o tempo inicial da contagem.

💬 Resumindo:
“Se o usuário digitar 1 hora, o React vai entender isso como 3.600.000 milissegundos.”





⏳ Parte 4 — Criando o efeito colateral (useEffect + setInterval):

Agora que temos o tempo, precisamos fazer ele diminuir de 1 em 1 segundo.
Pra isso usamos o useEffect, que cria um “efeito colateral”: algo que acontece automaticamente quando um valor muda.

useEffect(() => {
  if (contando) {
    const intervalo = setInterval(() => {
      setTempoRestante((valorAtual) => {
        if (valorAtual <= 1000) {
          clearInterval(intervalo);
          setContando(false);
          return 0;
        }
        return valorAtual - 1000;
      });
    }, 1000);

    return () => clearInterval(intervalo);
  }
}, [contando, tempoRestante]);



⚙️ Explicando passo a passo:

1️⃣ if (contando)

O intervalo só deve rodar se o contador estiver ativo.

2️⃣ setInterval(() => { ... }, 1000)

O setInterval executa uma função a cada X milissegundos.
Aqui, a cada 1000 ms (1 segundo).

📘 Estrutura básica:

setInterval(() => {
  // código repetido a cada intervalo
}, tempoEmMs);


🧩 Por que o nome “Interval”?
Porque ele repete algo em intervalos de tempo fixos.
Pense: “Execute essa função de segundo em segundo”.


💡 Comparação com setTimeout
Função	                 O que faz	                              Executa quantas vezes
setTimeout()             Executa uma vez após um tempo	          1 vez
setInterval()          	 Executa várias vezes no mesmo intervalo	infinitamente (até parar)



3️⃣ O cálculo interno:

Dentro do setInterval, usamos:

setTempoRestante((valorAtual) => {
  if (valorAtual <= 1000) {
    clearInterval(intervalo);
    setContando(false);
    return 0;
  }
  return valorAtual - 1000;
});


🧠 Entendendo:
. O React nos dá o valorAtual do estado (tempoRestante).
. Se o tempo for menor ou igual a 1000 ms (1 segundo), ele:
  . para o intervalo com clearInterval(intervalo);
  . interrompe a contagem (setContando(false));
  . e retorna 0 (pra zerar o contador).
. Caso contrário, ele subtrai 1000 ms (1 segundo).

Ou seja, a cada segundo, o valor é reduzido em 1000 até chegar a zero.


4️⃣ return () => clearInterval(intervalo):

Essa é a função de limpeza.
Ela roda automaticamente quando o useEffect for reexecutado ou desmontado.

🧩 Por que é importante?
Pra evitar múltiplos intervalos rodando ao mesmo tempo, o que geraria bugs ou contagens duplicadas.

5️⃣ Dependências [contando, tempoRestante]

O React vai observar essas variáveis.
Sempre que elas mudarem, o efeito será reavaliado — garantindo que o contador pare, reinicie ou continue corretamente.

💡 Exemplo completo de setInterval + clearInterval
const id = setInterval(() => {
  console.log("Executando...");
}, 1000);

setTimeout(() => {
  clearInterval(id);
  console.log("Parou o intervalo!");
}, 5000);


🧠 O que acontece:
. A cada segundo, aparece “Executando...”
. Após 5 segundos, o setTimeout executa e interrompe o intervalo.




🧮 Parte 5 — Convertendo o tempo em formato legível:

Queremos mostrar algo como:
00:01:23 → (0 horas, 1 minuto e 23 segundos).

function formatarTempo(ms) {
  const totalSegundos = Math.floor(ms / 1000);
  const horas = Math.floor(totalSegundos / 3600);
  const minutos = Math.floor((totalSegundos % 3600) / 60);
  const segundos = totalSegundos % 60;

  return `${horas.toString().padStart(2, "0")}:${minutos
    .toString()
    .padStart(2, "0")}:${segundos.toString().padStart(2, "0")}`;
}





🔹 Passo 1 — ms / 1000:

Converte milissegundos para segundos.

ms	                 /1000	                segundos
1000	               1000 / 1000 =          1	1s
2000	               2000 / 1000 =          2	2s
5000	               5000 / 1000 = 5	      5s
60000	               60000 / 1000 = 60	    60s = 1 min

📘 Conclusão:
Dividir por 1000 muda a unidade de tempo.
É o mesmo que dividir centímetros por 100 para virar metros.




🔹 Passo 2 — totalSegundos / 3600:

Converte segundos em horas.

💭 Por que 3600?
. 1 hora = 60 minutos
. 1 minuto = 60 segundos
👉 60 × 60 = 3600 segundos por hora

📘 Exemplo:

const totalSegundos = 7200;
const horas = Math.floor(totalSegundos / 3600); // 2 horas


7200 / 3600 = 2 → ou seja, duas horas completas.




🔹 Passo 3 — O operador % (resto da divisão):

O operador % pega o que sobra de uma divisão.

Exemplo:
10 % 3 = 1


Porque:
3 cabe 3 vezes em 10 → 3×3=9
Sobra 1.

Agora aplicando ao tempo:
const minutos = Math.floor((totalSegundos % 3600) / 60);


📘 Exemplo com 3723 segundos:
1️⃣ 3723 % 3600 = 123 → sobram 123 segundos
2️⃣ 123 / 60 = 2.05 → arredondando pra baixo → 2 minutos
3️⃣ 123 % 60 = 3 → sobram 3 segundos



💡 Resultado final:
1 hora, 2 minutos e 3 segundos

🔹 Passo 4 — Formatando o texto final
.toString()

Transforma um número em texto (string).

const numero = 9;
numero.toString(); // "9"

.padStart(2, "0")

Preenche o texto até ele ter 2 dígitos, com “0” à esquerda.

Exemplo	Resultado:
"5".padStart(2, "0")	"05"
"9".padStart(2, "0")	"09"
"12".padStart(2, "0")	"12"

💬 Start = início → adiciona à esquerda.
Existe também .padEnd() → adiciona à direita.

💡 Juntando tudo
return `${horas.toString().padStart(2, "0")}:${minutos
  .toString()
  .padStart(2, "0")}:${segundos.toString().padStart(2, "0")}`;


Isso garante que o formato fique sempre HH:MM:SS, mesmo se tiver só um dígito:
00:01:07
01:00:00



🧠 Resumo final:
Parte                     	Explicação simples
/ 1000	                    Converte milissegundos → segundos
/ 3600	                    Converte segundos → horas
/ 60	                      Converte segundos → minutos
%	                          Pega o resto da divisão
Math.floor()	              Arredonda pra baixo
toString()	                Transforma número em texto
padStart(2, "0")	          Garante 2 dígitos com zero à esquerda





💻 Parte 5 — Estrutura JSX (exibição da contagem regressiva)

Depois de criarmos toda a lógica, precisamos renderizar o contador na tela.
Essa é a parte responsável pela interação com o usuário: onde ele 
 define a duração e vê o tempo sendo reduzido em tempo real ⏳

<label htmlFor="duracao" className="py-2 font-bold text-lg">
  Duração (horas)
</label>

<input
  id="duracao"
  type="number"
  min="0"
  step="0.25"
  placeholder="Ex: 8 ou 1.5"
  value={duracaoEmHoras}
  onChange={(e) => setDuracaoEmHoras(e.target.value)}
  className="w-full p-2 border border-gray-300 rounded"
/>

<p className="mt-4 text-xl font-bold">
  Tempo restante:{" "}
  {tempoRestante > 0
    ? formatarTempo(tempoRestante)
    : "⏰ Tempo esgotado!"}
</p>

<button
  type="button"
  onClick={iniciarContagem}
  className="bg-green-600 text-white px-3 py-1 rounded hover:bg-green-700"
>
  Iniciar contagem
</button>

🧠 Entendendo o JSX

🔹 Label e Input:
. O label serve para identificar o campo de entrada.
. O input é do tipo number, permitindo que o usuário digite as horas de duração.
. O atributo step="0.25" permite valores fracionados (como 1.5 horas).
. O valor digitado é armazenado no estado duracaoEmHoras com o onChange.

🔹 Parágrafo (p):
. Exibe o tempo restante formatado usando nossa função formatarTempo.
. Quando tempoRestante chega a zero, mostra automaticamente “⏰ Tempo esgotado!”.

🔹 Botão:
. Dispara a função iniciarContagem, que faz a conversão, inicia o setInterval e ativa a contagem.
. O estilo muda a cor no hover e usa tons de verde para indicar “início”.

💡 Dica prática

Para testar rapidamente:
1. Digite por exemplo 0.001 horas (≈ 3,6 segundos).
2. Clique em Iniciar contagem.
3. Veja o contador descendo e, quando chegar a 0, aparecer “⏰ Tempo esgotado!”.

-->
