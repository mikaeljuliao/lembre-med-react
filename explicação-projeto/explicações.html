<!--
.

üìù Aula: Salvando e carregando dados com localStorage no React (vers√£o final)

1Ô∏è‚É£ O que √© localStorage?
. √â um recurso do navegador que guarda dados no pr√≥prio computador do usu√°rio.
. Diferente de um banco de dados, s√≥ guarda strings (texto).
. Os dados continuam l√° mesmo se o usu√°rio fechar ou recarregar a p√°gina.

Exemplo simples no console:
localStorage.setItem('nome', 'Mikael'); // salvar
localStorage.getItem('nome');           // "Mikael"


2Ô∏è‚É£ Por que usamos JSON.stringify e JSON.parse?
. O localStorage s√≥ aceita texto.
. Nosso estado remedios √© um array de objetos.
. Precisamos converter para string para salvar, e converter de volta para objeto para usar.

JSON.stringify(remedios) // transforma array/objeto em string JSON
JSON.parse(string)       // transforma string JSON de volta em array/objeto



3Ô∏è‚É£ A l√≥gica no React:
const [remedios, setRemedios] = useState(() => {
  const dadosSalvos = localStorage.getItem('remedios');
  return dadosSalvos ? JSON.parse(dadosSalvos) : [];
});

useEffect(() => {
  localStorage.setItem("remedios", JSON.stringify(remedios));
}, [remedios]);



4Ô∏è‚É£ Por que usamos useState(() => {...}) com fun√ß√£o inicial?
. O React s√≥ executa essa fun√ß√£o na primeira renderiza√ß√£o.
. Com isso, ele l√™ do localStorage uma √∫nica vez e j√° inicializa remedios com o que estava salvo.
. Sem essa fun√ß√£o, voc√™ precisaria de dois useEffect: um para carregar e outro para salvar.
. Assim, tudo fica mais limpo.



5Ô∏è‚É£ O operador tern√°rio (condi√ß√£o ? valor1 : valor2):

Dentro do useState usamos:
return dadosSalvos ? JSON.parse(dadosSalvos) : [];


Isso significa:
. Se dadosSalvos existe ‚Üí converte e retorna os dados.
. Se n√£o existe ‚Üí retorna um array vazio.


√â um jeito curto de escrever:
if (dadosSalvos) {
  return JSON.parse(dadosSalvos);
} else {
  return [];
}



6Ô∏è‚É£ O que significa o [remedios] no useEffect?
. √â a lista de depend√™ncias.
. O React s√≥ roda o useEffect de novo quando algo dessa lista muda.
. Colocando [remedios] ‚Üí ele roda sempre que remedios mudar.
. Se deixasse [], rodaria s√≥ uma vez no in√≠cio.



7Ô∏è‚É£ Detalhes do localStorage:
. O localStorage.setItem recebe 2 par√¢metros:
. Chave: nome do item (string) ‚Üí 'remedios'.
. Valor: o que quer salvar (tamb√©m string).

Ent√£o:
localStorage.setItem('remedios', JSON.stringify(remedios))

. "remedios" √© a chave.
. JSON.stringify(remedios) √© o valor salvo (string).


Para ler:
localStorage.getItem('remedios')

. Retorna a string. Se quiser o array de volta, faz:
. JSON.parse(localStorage.getItem('remedios'))



8Ô∏è‚É£ Resumo do fluxo
. P√°gina abre ‚Üí useState l√™ localStorage e preenche remedios.
. Usu√°rio adiciona um rem√©dio ‚Üí setRemedios atualiza o estado.
. useEffect detecta mudan√ßa em remedios ‚Üí salva os novos dados no localStorage.
. Se recarregar a p√°gina ‚Üí useState pega os dados salvos e carrega de volta.


9Ô∏è‚É£ Vantagens dessa abordagem
. N√£o precisa banco de dados para coisas simples.
. Os dados ficam sempre atualizados sem fun√ß√µes extras.
. Estado inicial j√° vem com os dados salvos (sem ‚Äúflash‚Äù vazio).
. Evita ter dois useEffect brigando entre si.


üí° Resumo em uma frase:
‚ÄúO localStorage √© um arm√°rio do navegador.
Usamos useState para pegar o que est√° dentro quando o app carrega,
e useEffect para guardar tudo de novo sempre que algo mudar.‚Äù
















üìö Aula: Listagem de Medicamentos no React

1. O objetivo da feature:

O que quer√≠amos com essa branch era:
. ‚úÖ Ler um arquivo JSON (medicamentos.json) com dados de medicamentos (nome, dose, frequ√™ncia, hor√°rio etc.).
. ‚úÖ Exibir esses dados automaticamente na tela, sem que o usu√°rio precise cadastrar.
. ‚úÖ Deixar esses dados separados da l√≥gica principal, ou seja, mant√™-los no JSON em vez de hardcodar dentro do componente.



2. Preparando os estados:
No React usamos estados (useState) para guardar informa√ß√µes que mudam durante a execu√ß√£o da aplica√ß√£o.

No come√ßo do componente criamos dois estados:

const [remedios, setRemedios] = useState([]); 
const [medicamentos, setMedicamentos] = useState([]);

. remedios ‚Üí armazena os medicamentos que o usu√°rio adiciona manualmente no formul√°rio.
. medicamentos ‚Üí armazena os medicamentos que v√™m do arquivo JSON.

Assim conseguimos trabalhar separadamente com cada fonte de dados.



3. Buscando o JSON com useEffect

Para carregar os dados assim que a p√°gina abre, usamos o hook useEffect.

useEffect(() => {
  fetch("/medicamentos.json")
    .then((res) => res.json())
    .then((data) => setMedicamentos(data))
    .catch((error) =>
      console.log("Erro ao carregar medicamentos", error)
    );
}, []);

Explica√ß√£o:
. fetch("/medicamentos.json") ‚Üí faz a requisi√ß√£o para o arquivo JSON.
. .then(res => res.json()) ‚Üí transforma a resposta em um objeto JavaScript.
. .then(data => setMedicamentos(data)) ‚Üí guarda esses dados no estado medicamentos.
. catch(...) ‚Üí captura poss√≠veis erros.
. O [] no final garante que isso s√≥ rode uma vez, quando o componente for montado.



4. Renderizando os medicamentos:

Depois que o JSON foi carregado no estado medicamentos, basta percorrer esse array com .map() e renderizar na tela.

<div className="mt-10">
  <ul>
    {medicamentos.map((medicamento) => (
      <li key={medicamento.id}>
        <strong>
          {medicamento.nome} - {medicamento.dose}
        </strong>{" "}
        <br />
        hor√°rio: {medicamento.horario} - frequ√™ncia:{" "}
        {medicamento.frequencia}
      </li>
    ))}
  </ul>
</div>


O que acontece aqui:
. medicamentos.map(...) ‚Üí percorre cada item do array.
. key={medicamento.id} ‚Üí cada item precisa de uma chave √∫nica.
. Dentro do JSX mostramos nome, dose, hor√°rio e frequ√™ncia.
. Ou seja, sempre que o arquivo JSON mudar, a interface automaticamente vai refletir esses dados.



5. Integra√ß√£o com a l√≥gica j√° existente:
Antes, nosso app s√≥ cadastrava manualmente com o formul√°rio (remedios).
Agora temos duas listas:

. Lista de rem√©dios cadastrados pelo usu√°rio
. Lista de medicamentos vindos do JSON

Assim a aplica√ß√£o mostra tanto o que o usu√°rio digitou quanto o que j√° estava registrado no ‚Äúbanco‚Äù de medicamentos.



6. Por que isso √© importante?
. üìÇ Separa√ß√£o de responsabilidades ‚Üí os dados ficam em um arquivo externo (JSON).
. ‚ö° Reutiliza√ß√£o ‚Üí podemos mudar o JSON sem alterar o c√≥digo.
. üîÑ Dinamicidade ‚Üí se o JSON for atualizado, a interface tamb√©m √©.
. üíª Pr√≥xima evolu√ß√£o ‚Üí no futuro, esse fetch pode vir de uma API real, sem mudar muita coisa no c√≥digo.


üöÄ Conclus√£o

Na branch listagem-medicamento, aprendemos:
1. Como usar useState para armazenar dados vindos de diferentes fontes.
2. Como usar useEffect + fetch para buscar dados de um JSON.
3. Como percorrer arrays com .map() para renderizar listas no React.
4. Como separar a l√≥gica de medicamentos cadastrados manualmente e carregados automaticamente.

Isso fecha a funcionalidade de listar medicamentos.

Na pr√°tica, voc√™ agora tem:
. Um mini banco de dados local (JSON).
. Integra√ß√£o desse ‚Äúbanco‚Äù com React.
. Exibi√ß√£o din√¢mica dos dados.
























üîπ 1. git checkout develop

Esse comando faz voc√™ entrar na branch develop.

Se j√° estiver nela, o Git responde algo como Already on 'develop'.

üîπ 2. git merge main

Aqui √© onde sempre rola confus√£o üëÄ

Esse comando pega o hist√≥rico da main e junta dentro da develop.

Ou seja: voc√™ est√° atualizando a develop com tudo que j√° existe na main.

N√£o √© o contr√°rio. A main n√£o recebe nada aqui.

üìå Ent√£o:

Branch ativa (onde voc√™ est√°) = quem vai ser atualizada.

Branch do merge (que voc√™ passa como argumento) = quem traz as mudan√ßas.

üëâ Como voc√™ estava em develop, o merge significa:

"junte as mudan√ßas da main dentro da develop".

üîπ 3. O que √© merge

Exatamente: merge = juntar o hist√≥rico de duas branches.
Ele cria um commit especial (merge commit) se houver diferen√ßas entre elas.
Se n√£o houver conflitos, o Git une automaticamente.

üìå Se houver conflitos, voc√™ precisa resolver manualmente (como aconteceu antes).

üîπ 4. git push origin develop

O push envia a sua branch local (develop) pro reposit√≥rio remoto (GitHub, GitLab etc.).

origin = apelido padr√£o pro reposit√≥rio remoto.

develop = branch que voc√™ est√° enviando.

üí° Se voc√™ s√≥ fizesse o merge localmente e n√£o desse o push, a develop remota ficaria desatualizada.
O push origin develop garante que a branch remota fique igual √† sua local.




‚úÖ Resumindo sua explica√ß√£o corrigida:
. checkout develop ‚Üí entro na branch develop.
. merge main ‚Üí atualizo develop com tudo que est√° na main.
. push origin develop ‚Üí envio a develop atualizada pro GitHub.


















üß† Aula: Criando a funcionalidade Remover Rem√©dio
üéØ Objetivo:

Permitir que o usu√°rio remova um rem√©dio da lista exibida na tela, de forma din√¢mica, sem precisar recarregar a p√°gina.

üß© Etapas de implementa√ß√£o
1Ô∏è‚É£ Entendimento do problema

Quer√≠amos que cada rem√©dio adicionado tivesse um bot√£o de remover.
Quando o usu√°rio clicasse, aquele rem√©dio deveria sumir da lista imediatamente.

Pra isso, precisar√≠amos:
. Acessar o estado atual da lista de rem√©dios (remedios);
. Remover apenas o item selecionado, sem alterar o resto;
. Atualizar o estado pra refletir essa mudan√ßa na interface 
(React faz isso automaticamente quando o estado muda).



2Ô∏è‚É£ Criando a fun√ß√£o de remover

Usamos o React Hook useState que controla a lista de rem√©dios:

const [remedios, setRemedios] = useState([]);


Depois criamos a fun√ß√£o removerRemedio:

function removerRemedio(idDoRemedio) {
  setRemedios((listaAnteriorDeRemedios) => 
    listaAnteriorDeRemedios.filter((remedio) => remedio.id !== idDoRemedio)
  );
}

üß© Explicando linha por linha:
. setRemedios(...) ‚Üí √© a fun√ß√£o que atualiza o estado remedios.
. (listaAnteriorDeRemedios) ‚Üí √© o estado antigo (a lista antes da remo√ß√£o).
Esse nome √© s√≥ pra clareza. Em alguns c√≥digos aparece como prev, que √© 
abrevia√ß√£o de previous, ou seja, ‚Äúanterior‚Äù.
. .filter() ‚Üí cria uma nova lista, sem modificar a original, mantendo apenas 
os elementos que passam no teste.
. (remedio) => remedio.id !== idDoRemedio ‚Üí esse √© o teste: s√≥ ficam na lista os 
rem√©dios cujo id n√£o √© igual ao id que queremos remover.
. O React ent√£o re-renderiza o componente mostrando a nova lista, j√° sem o rem√©dio removido.



3Ô∏è‚É£ Ligando o bot√£o √† fun√ß√£o:

Dentro do map() que mostra os rem√©dios na tela, adicionamos um bot√£o:

<button
  onClick={() => removerRemedio(remedio.id)}
  className="mt-2 bg-red-500 text-white px-3 py-1 rounded hover:bg-red-600"
>
  Remover
</button>

üß© O que acontece aqui:
. O onClick chama a fun√ß√£o removerRemedio, passando o id do rem√©dio.
. Assim que o bot√£o √© clicado, a fun√ß√£o roda e o item some da tela.



4Ô∏è‚É£ Testando a funcionalidade:

Passos testados:
1. Adicionar 2 ou mais rem√©dios.
2. Clicar em ‚ÄúRemover‚Äù em um deles.
3. Verificar se apenas aquele sumiu da lista.
4. Conferir se o resto da lista continua igual. ‚úÖ

üßπ Resultado final (resumo visual)
function removerRemedio(idDoRemedio) {
  setRemedios((listaAnterior) =>
    listaAnterior.filter((remedio) => remedio.id !== idDoRemedio)
  );
}



üí° Resumo conceitual:
.filter() percorre a lista e cria uma nova, com todos os itens que 
n√£o t√™m o ID igual ao que queremos remover.
Depois setRemedios atualiza o estado com essa nova lista.
O React automaticamente refaz a renderiza√ß√£o ‚Äî e o item desaparece da tela.


üìö Conclus√£o
. Usamos o conceito de imutabilidade do React: nunca alteramos o 
estado direto, sempre criamos uma nova lista.
. Entendemos o uso do callback no setState, pra trabalhar com o 
valor anterior de forma segura.
. Aplicamos o .filter(), uma fun√ß√£o nativa do JavaScript muito 
usada pra manipular arrays no React.
-->