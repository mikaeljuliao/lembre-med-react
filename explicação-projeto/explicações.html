<!--
.

ðŸ“ Aula: Salvando e carregando dados com localStorage no React (versÃ£o final)

1ï¸âƒ£ O que Ã© localStorage?
. Ã‰ um recurso do navegador que guarda dados no prÃ³prio computador do usuÃ¡rio.
. Diferente de um banco de dados, sÃ³ guarda strings (texto).
. Os dados continuam lÃ¡ mesmo se o usuÃ¡rio fechar ou recarregar a pÃ¡gina.

Exemplo simples no console:
localStorage.setItem('nome', 'Mikael'); // salvar
localStorage.getItem('nome');           // "Mikael"


2ï¸âƒ£ Por que usamos JSON.stringify e JSON.parse?
. O localStorage sÃ³ aceita texto.
. Nosso estado remedios Ã© um array de objetos.
. Precisamos converter para string para salvar, e converter de volta para objeto para usar.

JSON.stringify(remedios) // transforma array/objeto em string JSON
JSON.parse(string)       // transforma string JSON de volta em array/objeto



3ï¸âƒ£ A lÃ³gica no React:
const [remedios, setRemedios] = useState(() => {
  const dadosSalvos = localStorage.getItem('remedios');
  return dadosSalvos ? JSON.parse(dadosSalvos) : [];
});

useEffect(() => {
  localStorage.setItem("remedios", JSON.stringify(remedios));
}, [remedios]);



4ï¸âƒ£ Por que usamos useState(() => {...}) com funÃ§Ã£o inicial?
. O React sÃ³ executa essa funÃ§Ã£o na primeira renderizaÃ§Ã£o.
. Com isso, ele lÃª do localStorage uma Ãºnica vez e jÃ¡ inicializa remedios com o que estava salvo.
. Sem essa funÃ§Ã£o, vocÃª precisaria de dois useEffect: um para carregar e outro para salvar.
. Assim, tudo fica mais limpo.



5ï¸âƒ£ O operador ternÃ¡rio (condiÃ§Ã£o ? valor1 : valor2):

Dentro do useState usamos:
return dadosSalvos ? JSON.parse(dadosSalvos) : [];


Isso significa:
. Se dadosSalvos existe â†’ converte e retorna os dados.
. Se nÃ£o existe â†’ retorna um array vazio.


Ã‰ um jeito curto de escrever:
if (dadosSalvos) {
  return JSON.parse(dadosSalvos);
} else {
  return [];
}



6ï¸âƒ£ O que significa o [remedios] no useEffect?
. Ã‰ a lista de dependÃªncias.
. O React sÃ³ roda o useEffect de novo quando algo dessa lista muda.
. Colocando [remedios] â†’ ele roda sempre que remedios mudar.
. Se deixasse [], rodaria sÃ³ uma vez no inÃ­cio.



7ï¸âƒ£ Detalhes do localStorage:
. O localStorage.setItem recebe 2 parÃ¢metros:
. Chave: nome do item (string) â†’ 'remedios'.
. Valor: o que quer salvar (tambÃ©m string).

EntÃ£o:
localStorage.setItem('remedios', JSON.stringify(remedios))

. "remedios" Ã© a chave.
. JSON.stringify(remedios) Ã© o valor salvo (string).


Para ler:
localStorage.getItem('remedios')

. Retorna a string. Se quiser o array de volta, faz:
. JSON.parse(localStorage.getItem('remedios'))



8ï¸âƒ£ Resumo do fluxo
. PÃ¡gina abre â†’ useState lÃª localStorage e preenche remedios.
. UsuÃ¡rio adiciona um remÃ©dio â†’ setRemedios atualiza o estado.
. useEffect detecta mudanÃ§a em remedios â†’ salva os novos dados no localStorage.
. Se recarregar a pÃ¡gina â†’ useState pega os dados salvos e carrega de volta.


9ï¸âƒ£ Vantagens dessa abordagem
. NÃ£o precisa banco de dados para coisas simples.
. Os dados ficam sempre atualizados sem funÃ§Ãµes extras.
. Estado inicial jÃ¡ vem com os dados salvos (sem â€œflashâ€ vazio).
. Evita ter dois useEffect brigando entre si.


ðŸ’¡ Resumo em uma frase:
â€œO localStorage Ã© um armÃ¡rio do navegador.
Usamos useState para pegar o que estÃ¡ dentro quando o app carrega,
e useEffect para guardar tudo de novo sempre que algo mudar.â€
















ðŸ“š Aula: Listagem de Medicamentos no React

1. O objetivo da feature:

O que querÃ­amos com essa branch era:
. âœ… Ler um arquivo JSON (medicamentos.json) com dados de medicamentos (nome, dose, frequÃªncia, horÃ¡rio etc.).
. âœ… Exibir esses dados automaticamente na tela, sem que o usuÃ¡rio precise cadastrar.
. âœ… Deixar esses dados separados da lÃ³gica principal, ou seja, mantÃª-los no JSON em vez de hardcodar dentro do componente.



2. Preparando os estados:
No React usamos estados (useState) para guardar informaÃ§Ãµes que mudam durante a execuÃ§Ã£o da aplicaÃ§Ã£o.

No comeÃ§o do componente criamos dois estados:

const [remedios, setRemedios] = useState([]); 
const [medicamentos, setMedicamentos] = useState([]);

. remedios â†’ armazena os medicamentos que o usuÃ¡rio adiciona manualmente no formulÃ¡rio.
. medicamentos â†’ armazena os medicamentos que vÃªm do arquivo JSON.

Assim conseguimos trabalhar separadamente com cada fonte de dados.



3. Buscando o JSON com useEffect

Para carregar os dados assim que a pÃ¡gina abre, usamos o hook useEffect.

useEffect(() => {
  fetch("/medicamentos.json")
    .then((res) => res.json())
    .then((data) => setMedicamentos(data))
    .catch((error) =>
      console.log("Erro ao carregar medicamentos", error)
    );
}, []);

ExplicaÃ§Ã£o:
. fetch("/medicamentos.json") â†’ faz a requisiÃ§Ã£o para o arquivo JSON.
. .then(res => res.json()) â†’ transforma a resposta em um objeto JavaScript.
. .then(data => setMedicamentos(data)) â†’ guarda esses dados no estado medicamentos.
. catch(...) â†’ captura possÃ­veis erros.
. O [] no final garante que isso sÃ³ rode uma vez, quando o componente for montado.



4. Renderizando os medicamentos:

Depois que o JSON foi carregado no estado medicamentos, basta percorrer esse array com .map() e renderizar na tela.

<div className="mt-10">
  <ul>
    {medicamentos.map((medicamento) => (
      <li key={medicamento.id}>
        <strong>
          {medicamento.nome} - {medicamento.dose}
        </strong>{" "}
        <br />
        horÃ¡rio: {medicamento.horario} - frequÃªncia:{" "}
        {medicamento.frequencia}
      </li>
    ))}
  </ul>
</div>


O que acontece aqui:
. medicamentos.map(...) â†’ percorre cada item do array.
. key={medicamento.id} â†’ cada item precisa de uma chave Ãºnica.
. Dentro do JSX mostramos nome, dose, horÃ¡rio e frequÃªncia.
. Ou seja, sempre que o arquivo JSON mudar, a interface automaticamente vai refletir esses dados.



5. IntegraÃ§Ã£o com a lÃ³gica jÃ¡ existente:
Antes, nosso app sÃ³ cadastrava manualmente com o formulÃ¡rio (remedios).
Agora temos duas listas:

. Lista de remÃ©dios cadastrados pelo usuÃ¡rio
. Lista de medicamentos vindos do JSON

Assim a aplicaÃ§Ã£o mostra tanto o que o usuÃ¡rio digitou quanto o que jÃ¡ estava registrado no â€œbancoâ€ de medicamentos.



6. Por que isso Ã© importante?
. ðŸ“‚ SeparaÃ§Ã£o de responsabilidades â†’ os dados ficam em um arquivo externo (JSON).
. âš¡ ReutilizaÃ§Ã£o â†’ podemos mudar o JSON sem alterar o cÃ³digo.
. ðŸ”„ Dinamicidade â†’ se o JSON for atualizado, a interface tambÃ©m Ã©.
. ðŸ’» PrÃ³xima evoluÃ§Ã£o â†’ no futuro, esse fetch pode vir de uma API real, sem mudar muita coisa no cÃ³digo.


ðŸš€ ConclusÃ£o

Na branch listagem-medicamento, aprendemos:
1. Como usar useState para armazenar dados vindos de diferentes fontes.
2. Como usar useEffect + fetch para buscar dados de um JSON.
3. Como percorrer arrays com .map() para renderizar listas no React.
4. Como separar a lÃ³gica de medicamentos cadastrados manualmente e carregados automaticamente.

Isso fecha a funcionalidade de listar medicamentos.

Na prÃ¡tica, vocÃª agora tem:
. Um mini banco de dados local (JSON).
. IntegraÃ§Ã£o desse â€œbancoâ€ com React.
. ExibiÃ§Ã£o dinÃ¢mica dos dados.
-->