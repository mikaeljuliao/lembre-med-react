<!--
.

📝 Aula: Salvando e carregando dados com localStorage no React (versão final)

1️⃣ O que é localStorage?
. É um recurso do navegador que guarda dados no próprio computador do usuário.
. Diferente de um banco de dados, só guarda strings (texto).
. Os dados continuam lá mesmo se o usuário fechar ou recarregar a página.

Exemplo simples no console:
localStorage.setItem('nome', 'Mikael'); // salvar
localStorage.getItem('nome');           // "Mikael"


2️⃣ Por que usamos JSON.stringify e JSON.parse?
. O localStorage só aceita texto.
. Nosso estado remedios é um array de objetos.
. Precisamos converter para string para salvar, e converter de volta para objeto para usar.

JSON.stringify(remedios) // transforma array/objeto em string JSON
JSON.parse(string)       // transforma string JSON de volta em array/objeto



3️⃣ A lógica no React:
const [remedios, setRemedios] = useState(() => {
  const dadosSalvos = localStorage.getItem('remedios');
  return dadosSalvos ? JSON.parse(dadosSalvos) : [];
});

useEffect(() => {
  localStorage.setItem("remedios", JSON.stringify(remedios));
}, [remedios]);



4️⃣ Por que usamos useState(() => {...}) com função inicial?
. O React só executa essa função na primeira renderização.
. Com isso, ele lê do localStorage uma única vez e já inicializa remedios com o que estava salvo.
. Sem essa função, você precisaria de dois useEffect: um para carregar e outro para salvar.
. Assim, tudo fica mais limpo.



5️⃣ O operador ternário (condição ? valor1 : valor2):

Dentro do useState usamos:
return dadosSalvos ? JSON.parse(dadosSalvos) : [];


Isso significa:
. Se dadosSalvos existe → converte e retorna os dados.
. Se não existe → retorna um array vazio.


É um jeito curto de escrever:
if (dadosSalvos) {
  return JSON.parse(dadosSalvos);
} else {
  return [];
}



6️⃣ O que significa o [remedios] no useEffect?
. É a lista de dependências.
. O React só roda o useEffect de novo quando algo dessa lista muda.
. Colocando [remedios] → ele roda sempre que remedios mudar.
. Se deixasse [], rodaria só uma vez no início.



7️⃣ Detalhes do localStorage:
. O localStorage.setItem recebe 2 parâmetros:
. Chave: nome do item (string) → 'remedios'.
. Valor: o que quer salvar (também string).

Então:
localStorage.setItem('remedios', JSON.stringify(remedios))

. "remedios" é a chave.
. JSON.stringify(remedios) é o valor salvo (string).


Para ler:
localStorage.getItem('remedios')

. Retorna a string. Se quiser o array de volta, faz:
. JSON.parse(localStorage.getItem('remedios'))



8️⃣ Resumo do fluxo
. Página abre → useState lê localStorage e preenche remedios.
. Usuário adiciona um remédio → setRemedios atualiza o estado.
. useEffect detecta mudança em remedios → salva os novos dados no localStorage.
. Se recarregar a página → useState pega os dados salvos e carrega de volta.


9️⃣ Vantagens dessa abordagem
. Não precisa banco de dados para coisas simples.
. Os dados ficam sempre atualizados sem funções extras.
. Estado inicial já vem com os dados salvos (sem “flash” vazio).
. Evita ter dois useEffect brigando entre si.


💡 Resumo em uma frase:
“O localStorage é um armário do navegador.
Usamos useState para pegar o que está dentro quando o app carrega,
e useEffect para guardar tudo de novo sempre que algo mudar.”
















📚 Aula: Listagem de Medicamentos no React

1. O objetivo da feature:

O que queríamos com essa branch era:
. ✅ Ler um arquivo JSON (medicamentos.json) com dados de medicamentos (nome, dose, frequência, horário etc.).
. ✅ Exibir esses dados automaticamente na tela, sem que o usuário precise cadastrar.
. ✅ Deixar esses dados separados da lógica principal, ou seja, mantê-los no JSON em vez de hardcodar dentro do componente.



2. Preparando os estados:
No React usamos estados (useState) para guardar informações que mudam durante a execução da aplicação.

No começo do componente criamos dois estados:

const [remedios, setRemedios] = useState([]); 
const [medicamentos, setMedicamentos] = useState([]);

. remedios → armazena os medicamentos que o usuário adiciona manualmente no formulário.
. medicamentos → armazena os medicamentos que vêm do arquivo JSON.

Assim conseguimos trabalhar separadamente com cada fonte de dados.



3. Buscando o JSON com useEffect

Para carregar os dados assim que a página abre, usamos o hook useEffect.

useEffect(() => {
  fetch("/medicamentos.json")
    .then((res) => res.json())
    .then((data) => setMedicamentos(data))
    .catch((error) =>
      console.log("Erro ao carregar medicamentos", error)
    );
}, []);

Explicação:
. fetch("/medicamentos.json") → faz a requisição para o arquivo JSON.
. .then(res => res.json()) → transforma a resposta em um objeto JavaScript.
. .then(data => setMedicamentos(data)) → guarda esses dados no estado medicamentos.
. catch(...) → captura possíveis erros.
. O [] no final garante que isso só rode uma vez, quando o componente for montado.



4. Renderizando os medicamentos:

Depois que o JSON foi carregado no estado medicamentos, basta percorrer esse array com .map() e renderizar na tela.

<div className="mt-10">
  <ul>
    {medicamentos.map((medicamento) => (
      <li key={medicamento.id}>
        <strong>
          {medicamento.nome} - {medicamento.dose}
        </strong>{" "}
        <br />
        horário: {medicamento.horario} - frequência:{" "}
        {medicamento.frequencia}
      </li>
    ))}
  </ul>
</div>


O que acontece aqui:
. medicamentos.map(...) → percorre cada item do array.
. key={medicamento.id} → cada item precisa de uma chave única.
. Dentro do JSX mostramos nome, dose, horário e frequência.
. Ou seja, sempre que o arquivo JSON mudar, a interface automaticamente vai refletir esses dados.



5. Integração com a lógica já existente:
Antes, nosso app só cadastrava manualmente com o formulário (remedios).
Agora temos duas listas:

. Lista de remédios cadastrados pelo usuário
. Lista de medicamentos vindos do JSON

Assim a aplicação mostra tanto o que o usuário digitou quanto o que já estava registrado no “banco” de medicamentos.



6. Por que isso é importante?
. 📂 Separação de responsabilidades → os dados ficam em um arquivo externo (JSON).
. ⚡ Reutilização → podemos mudar o JSON sem alterar o código.
. 🔄 Dinamicidade → se o JSON for atualizado, a interface também é.
. 💻 Próxima evolução → no futuro, esse fetch pode vir de uma API real, sem mudar muita coisa no código.


🚀 Conclusão

Na branch listagem-medicamento, aprendemos:
1. Como usar useState para armazenar dados vindos de diferentes fontes.
2. Como usar useEffect + fetch para buscar dados de um JSON.
3. Como percorrer arrays com .map() para renderizar listas no React.
4. Como separar a lógica de medicamentos cadastrados manualmente e carregados automaticamente.

Isso fecha a funcionalidade de listar medicamentos.

Na prática, você agora tem:
. Um mini banco de dados local (JSON).
. Integração desse “banco” com React.
. Exibição dinâmica dos dados.
























🔹 1. git checkout develop

Esse comando faz você entrar na branch develop.

Se já estiver nela, o Git responde algo como Already on 'develop'.

🔹 2. git merge main

Aqui é onde sempre rola confusão 👀

Esse comando pega o histórico da main e junta dentro da develop.

Ou seja: você está atualizando a develop com tudo que já existe na main.

Não é o contrário. A main não recebe nada aqui.

📌 Então:

Branch ativa (onde você está) = quem vai ser atualizada.

Branch do merge (que você passa como argumento) = quem traz as mudanças.

👉 Como você estava em develop, o merge significa:

"junte as mudanças da main dentro da develop".

🔹 3. O que é merge

Exatamente: merge = juntar o histórico de duas branches.
Ele cria um commit especial (merge commit) se houver diferenças entre elas.
Se não houver conflitos, o Git une automaticamente.

📌 Se houver conflitos, você precisa resolver manualmente (como aconteceu antes).

🔹 4. git push origin develop

O push envia a sua branch local (develop) pro repositório remoto (GitHub, GitLab etc.).

origin = apelido padrão pro repositório remoto.

develop = branch que você está enviando.

💡 Se você só fizesse o merge localmente e não desse o push, a develop remota ficaria desatualizada.
O push origin develop garante que a branch remota fique igual à sua local.




✅ Resumindo sua explicação corrigida:
. checkout develop → entro na branch develop.
. merge main → atualizo develop com tudo que está na main.
. push origin develop → envio a develop atualizada pro GitHub.


















🧠 Aula: Criando a funcionalidade Remover Remédio
🎯 Objetivo:

Permitir que o usuário remova um remédio da lista exibida na tela, de forma dinâmica, sem precisar recarregar a página.

🧩 Etapas de implementação
1️⃣ Entendimento do problema

Queríamos que cada remédio adicionado tivesse um botão de remover.
Quando o usuário clicasse, aquele remédio deveria sumir da lista imediatamente.

Pra isso, precisaríamos:
. Acessar o estado atual da lista de remédios (remedios);
. Remover apenas o item selecionado, sem alterar o resto;
. Atualizar o estado pra refletir essa mudança na interface 
(React faz isso automaticamente quando o estado muda).



2️⃣ Criando a função de remover

Usamos o React Hook useState que controla a lista de remédios:

const [remedios, setRemedios] = useState([]);


Depois criamos a função removerRemedio:

function removerRemedio(idDoRemedio) {
  setRemedios((listaAnteriorDeRemedios) => 
    listaAnteriorDeRemedios.filter((remedio) => remedio.id !== idDoRemedio)
  );
}

🧩 Explicando linha por linha:
. setRemedios(...) → é a função que atualiza o estado remedios.
. (listaAnteriorDeRemedios) → é o estado antigo (a lista antes da remoção).
Esse nome é só pra clareza. Em alguns códigos aparece como prev, que é 
abreviação de previous, ou seja, “anterior”.
. .filter() → cria uma nova lista, sem modificar a original, mantendo apenas 
os elementos que passam no teste.
. (remedio) => remedio.id !== idDoRemedio → esse é o teste: só ficam na lista os 
remédios cujo id não é igual ao id que queremos remover.
. O React então re-renderiza o componente mostrando a nova lista, já sem o remédio removido.



3️⃣ Ligando o botão à função:

Dentro do map() que mostra os remédios na tela, adicionamos um botão:

<button
  onClick={() => removerRemedio(remedio.id)}
  className="mt-2 bg-red-500 text-white px-3 py-1 rounded hover:bg-red-600"
>
  Remover
</button>

🧩 O que acontece aqui:
. O onClick chama a função removerRemedio, passando o id do remédio.
. Assim que o botão é clicado, a função roda e o item some da tela.



4️⃣ Testando a funcionalidade:

Passos testados:
1. Adicionar 2 ou mais remédios.
2. Clicar em “Remover” em um deles.
3. Verificar se apenas aquele sumiu da lista.
4. Conferir se o resto da lista continua igual. ✅

🧹 Resultado final (resumo visual)
function removerRemedio(idDoRemedio) {
  setRemedios((listaAnterior) =>
    listaAnterior.filter((remedio) => remedio.id !== idDoRemedio)
  );
}



💡 Resumo conceitual:
.filter() percorre a lista e cria uma nova, com todos os itens que 
não têm o ID igual ao que queremos remover.
Depois setRemedios atualiza o estado com essa nova lista.
O React automaticamente refaz a renderização — e o item desaparece da tela.


📚 Conclusão
. Usamos o conceito de imutabilidade do React: nunca alteramos o 
estado direto, sempre criamos uma nova lista.
. Entendemos o uso do callback no setState, pra trabalhar com o 
valor anterior de forma segura.
. Aplicamos o .filter(), uma função nativa do JavaScript muito 
usada pra manipular arrays no React.
-->